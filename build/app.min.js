var COMGALLERY =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ui_nav__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui/nav */ \"./js/ui/nav.js\");\n/* harmony import */ var _modules_gallery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/gallery */ \"./js/modules/gallery.js\");\n/** App entry */\n\n\n\nclass App {\n  constructor() {\n    this.modules = {\n      gallery: new _modules_gallery__WEBPACK_IMPORTED_MODULE_1__[\"default\"](),\n      nav: new _ui_nav__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n    };\n    Object.keys(this.modules).forEach(key => {\n      this.modules[key].bind(this);\n    });\n  }\n\n}\n\nwindow.onload = () => {\n  const app = new App();\n};\n\n//# sourceURL=webpack://COMGALLERY/./js/app.js?");

/***/ }),

/***/ "./js/glsl/CopyShader.js":
/*!*******************************!*\
  !*** ./js/glsl/CopyShader.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Full-screen textured quad shader\r\n */\nTHREE.CopyShader = {\n  uniforms: {\n    \"tDiffuse\": {\n      value: null\n    },\n    \"opacity\": {\n      value: 1.0\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = opacity * texel;\", \"}\"].join(\"\\n\")\n};\n\n//# sourceURL=webpack://COMGALLERY/./js/glsl/CopyShader.js?");

/***/ }),

/***/ "./js/glsl/EffectComposer.js":
/*!***********************************!*\
  !*** ./js/glsl/EffectComposer.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\nTHREE.EffectComposer = function (renderer, renderTarget) {\n  this.renderer = renderer;\n\n  if (renderTarget === undefined) {\n    var parameters = {\n      minFilter: THREE.LinearFilter,\n      magFilter: THREE.LinearFilter,\n      format: THREE.RGBAFormat,\n      stencilBuffer: false\n    };\n    var size = renderer.getSize(new THREE.Vector2());\n    this._pixelRatio = renderer.getPixelRatio();\n    this._width = size.width;\n    this._height = size.height;\n    renderTarget = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);\n    renderTarget.texture.name = 'EffectComposer.rt1';\n  } else {\n    this._pixelRatio = 1;\n    this._width = renderTarget.width;\n    this._height = renderTarget.height;\n  }\n\n  this.renderTarget1 = renderTarget;\n  this.renderTarget2 = renderTarget.clone();\n  this.renderTarget2.texture.name = 'EffectComposer.rt2';\n  this.writeBuffer = this.renderTarget1;\n  this.readBuffer = this.renderTarget2;\n  this.renderToScreen = true;\n  this.passes = []; // dependencies\n\n  if (THREE.CopyShader === undefined) {\n    console.error('THREE.EffectComposer relies on THREE.CopyShader');\n  }\n\n  if (THREE.ShaderPass === undefined) {\n    console.error('THREE.EffectComposer relies on THREE.ShaderPass');\n  }\n\n  this.copyPass = new THREE.ShaderPass(THREE.CopyShader);\n  this.clock = new THREE.Clock();\n};\n\nObject.assign(THREE.EffectComposer.prototype, {\n  swapBuffers: function () {\n    var tmp = this.readBuffer;\n    this.readBuffer = this.writeBuffer;\n    this.writeBuffer = tmp;\n  },\n  addPass: function (pass) {\n    this.passes.push(pass);\n    var size = this.renderer.getDrawingBufferSize(new THREE.Vector2());\n    pass.setSize(size.width, size.height);\n  },\n  insertPass: function (pass, index) {\n    this.passes.splice(index, 0, pass);\n  },\n  isLastEnabledPass: function (passIndex) {\n    for (var i = passIndex + 1; i < this.passes.length; i++) {\n      if (this.passes[i].enabled) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  render: function (deltaTime) {\n    // deltaTime value is in seconds\n    if (deltaTime === undefined) {\n      deltaTime = this.clock.getDelta();\n    }\n\n    var currentRenderTarget = this.renderer.getRenderTarget();\n    var maskActive = false;\n    var pass,\n        i,\n        il = this.passes.length;\n\n    for (i = 0; i < il; i++) {\n      pass = this.passes[i];\n      if (pass.enabled === false) continue;\n      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);\n      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);\n\n      if (pass.needsSwap) {\n        if (maskActive) {\n          var context = this.renderer.context;\n          context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\n          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);\n          context.stencilFunc(context.EQUAL, 1, 0xffffffff);\n        }\n\n        this.swapBuffers();\n      }\n\n      if (THREE.MaskPass !== undefined) {\n        if (pass instanceof THREE.MaskPass) {\n          maskActive = true;\n        } else if (pass instanceof THREE.ClearMaskPass) {\n          maskActive = false;\n        }\n      }\n    }\n\n    this.renderer.setRenderTarget(currentRenderTarget);\n  },\n  reset: function (renderTarget) {\n    if (renderTarget === undefined) {\n      var size = this.renderer.getSize(new THREE.Vector2());\n      this._pixelRatio = this.renderer.getPixelRatio();\n      this._width = size.width;\n      this._height = size.height;\n      renderTarget = this.renderTarget1.clone();\n      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n    }\n\n    this.renderTarget1.dispose();\n    this.renderTarget2.dispose();\n    this.renderTarget1 = renderTarget;\n    this.renderTarget2 = renderTarget.clone();\n    this.writeBuffer = this.renderTarget1;\n    this.readBuffer = this.renderTarget2;\n  },\n  setSize: function (width, height) {\n    this._width = width;\n    this._height = height;\n    var effectiveWidth = this._width * this._pixelRatio;\n    var effectiveHeight = this._height * this._pixelRatio;\n    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);\n    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);\n\n    for (var i = 0; i < this.passes.length; i++) {\n      this.passes[i].setSize(effectiveWidth, effectiveHeight);\n    }\n  },\n  setPixelRatio: function (pixelRatio) {\n    this._pixelRatio = pixelRatio;\n    this.setSize(this._width, this._height);\n  }\n});\n\nTHREE.Pass = function () {\n  // if set to true, the pass is processed by the composer\n  this.enabled = true; // if set to true, the pass indicates to swap read and write buffer after rendering\n\n  this.needsSwap = true; // if set to true, the pass clears its buffer before rendering\n\n  this.clear = false; // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\n  this.renderToScreen = false;\n};\n\nObject.assign(THREE.Pass.prototype, {\n  setSize: function ()\n  /* width, height */\n  {},\n  render: function ()\n  /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */\n  {\n    console.error('THREE.Pass: .render() must be implemented in derived pass.');\n  }\n}); // Helper for passes that need to fill the viewport with a single quad.\n\nTHREE.Pass.FullScreenQuad = function () {\n  var camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  var geometry = new THREE.PlaneBufferGeometry(2, 2);\n\n  var FullScreenQuad = function (material) {\n    this._mesh = new THREE.Mesh(geometry, material);\n  };\n\n  Object.defineProperty(FullScreenQuad.prototype, 'material', {\n    get: function () {\n      return this._mesh.material;\n    },\n    set: function (value) {\n      this._mesh.material = value;\n    }\n  });\n  Object.assign(FullScreenQuad.prototype, {\n    render: function (renderer) {\n      renderer.render(this._mesh, camera);\n    }\n  });\n  return FullScreenQuad;\n}();\n\n//# sourceURL=webpack://COMGALLERY/./js/glsl/EffectComposer.js?");

/***/ }),

/***/ "./js/glsl/LuminosityHighPassShader.js":
/*!*********************************************!*\
  !*** ./js/glsl/LuminosityHighPassShader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author bhouston / http://clara.io/\r\n *\r\n * Luminosity\r\n * http://en.wikipedia.org/wiki/Luminosity\r\n */\nTHREE.LuminosityHighPassShader = {\n  shaderID: \"luminosityHighPass\",\n  uniforms: {\n    \"tDiffuse\": {\n      type: \"t\",\n      value: null\n    },\n    \"luminosityThreshold\": {\n      type: \"f\",\n      value: 1.0\n    },\n    \"smoothWidth\": {\n      type: \"f\",\n      value: 1.0\n    },\n    \"defaultColor\": {\n      type: \"c\",\n      value: new THREE.Color(0x000000)\n    },\n    \"defaultOpacity\": {\n      type: \"f\",\n      value: 0.0\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 defaultColor;\", \"uniform float defaultOpacity;\", \"uniform float luminosityThreshold;\", \"uniform float smoothWidth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\", \"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\", \"gl_FragColor = mix( outputColor, texel, alpha );\", \"}\"].join(\"\\n\")\n};\n\n//# sourceURL=webpack://COMGALLERY/./js/glsl/LuminosityHighPassShader.js?");

/***/ }),

/***/ "./js/glsl/Poster.js":
/*!***************************!*\
  !*** ./js/glsl/Poster.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n  @author meatbags / https://github.com/meatbags\r\n  **/\nTHREE.PosterShader = {\n  uniforms: {\n    'tDiffuse': {\n      value: null\n    }\n  },\n  vertexShader: `\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    #define PI 3.14159\n    #define UV_SCALE 0.02\n    #define MAX_HEIGHT 0.5\n    varying vec2 vUv;\n    uniform sampler2D tDiffuse;\n\n    float posterise(float val, float amount) {\n      return floor(val * amount) / amount;\n    }\n\n    float posteriseCeil(float val, float amount) {\n      return ceil(val * amount) / amount;\n    }\n\n    void main() {\n      vec4 frag = texture2D(tDiffuse, vUv);\n      frag.r = posterise(frag.r, 16.0);\n      gl_FragColor = frag;\n    }\n  `\n}; // render pass\n\nTHREE.PosterPass = function (size) {\n  THREE.Pass.call(this);\n  this.size = size;\n  this.shader = THREE.PosterShader;\n  this.material = new THREE.ShaderMaterial(this.shader);\n  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  this.scene = new THREE.Scene();\n  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.material);\n  this.quad.frustumCulled = false;\n  this.scene.add(this.quad);\n  this.time = 0;\n};\n\nTHREE.PosterPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n  constructor: THREE.PosterPass,\n  render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n    this.shader.uniforms['tDiffuse'].value = readBuffer.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n    }\n  }\n});\n\n//# sourceURL=webpack://COMGALLERY/./js/glsl/Poster.js?");

/***/ }),

/***/ "./js/glsl/RenderPass.js":
/*!*******************************!*\
  !*** ./js/glsl/RenderPass.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\nTHREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {\n  THREE.Pass.call(this);\n  this.scene = scene;\n  this.camera = camera;\n  this.overrideMaterial = overrideMaterial;\n  this.clearColor = clearColor;\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n  this.clear = true;\n  this.clearDepth = false;\n  this.needsSwap = false;\n};\n\nTHREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n  constructor: THREE.RenderPass,\n  render: function (renderer, writeBuffer, readBuffer\n  /*, deltaTime, maskActive */\n  ) {\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.scene.overrideMaterial = this.overrideMaterial;\n    var oldClearColor, oldClearAlpha;\n\n    if (this.clearColor) {\n      oldClearColor = renderer.getClearColor().getHex();\n      oldClearAlpha = renderer.getClearAlpha();\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n    }\n\n    if (this.clearDepth) {\n      renderer.clearDepth();\n    }\n\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\n    if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n    renderer.render(this.scene, this.camera);\n\n    if (this.clearColor) {\n      renderer.setClearColor(oldClearColor, oldClearAlpha);\n    }\n\n    this.scene.overrideMaterial = null;\n    renderer.autoClear = oldAutoClear;\n  }\n});\n\n//# sourceURL=webpack://COMGALLERY/./js/glsl/RenderPass.js?");

/***/ }),

/***/ "./js/glsl/ShaderPass.js":
/*!*******************************!*\
  !*** ./js/glsl/ShaderPass.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\nTHREE.ShaderPass = function (shader, textureID) {\n  THREE.Pass.call(this);\n  this.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n\n  if (shader instanceof THREE.ShaderMaterial) {\n    this.uniforms = shader.uniforms;\n    this.material = shader;\n  } else if (shader) {\n    this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n    this.material = new THREE.ShaderMaterial({\n      defines: shader.defines || {},\n      uniforms: this.uniforms,\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader\n    });\n  }\n\n  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  this.scene = new THREE.Scene();\n  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n  this.quad.frustumCulled = false; // Avoid getting clipped\n\n  this.scene.add(this.quad);\n};\n\nTHREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n  constructor: THREE.ShaderPass,\n  render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n    if (this.uniforms[this.textureID]) {\n      this.uniforms[this.textureID].value = readBuffer.texture;\n    }\n\n    this.quad.material = this.material;\n\n    if (this.renderToScreen) {\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.render(this.scene, this.camera, writeBuffer, this.clear);\n    }\n  }\n});\n\n//# sourceURL=webpack://COMGALLERY/./js/glsl/ShaderPass.js?");

/***/ }),

/***/ "./js/glsl/UnrealBloomPass.js":
/*!************************************!*\
  !*** ./js/glsl/UnrealBloomPass.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author spidersharma / http://eduperiment.com/\r\n *\r\n * Inspired from Unreal Engine\r\n * https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\nTHREE.UnrealBloomPass = function (resolution, strength, radius, threshold) {\n  THREE.Pass.call(this);\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new THREE.Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    format: THREE.RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n  this.renderTargetBright.texture.generateMipmaps = false;\n\n  for (var i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n\n  if (THREE.LuminosityHighPassShader === undefined) console.error(\"THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader\");\n  var highPassShader = THREE.LuminosityHighPassShader;\n  this.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n  this.highPassUniforms[\"smoothWidth\"].value = 0.01;\n  this.materialHighPassFilter = new THREE.ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n\n  for (var i = 0; i < this.nMips; i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n    this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n  this.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n  this.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors; // copy material\n\n  if (THREE.CopyShader === undefined) {\n    console.error(\"THREE.UnrealBloomPass relies on THREE.CopyShader\");\n  }\n\n  var copyShader = THREE.CopyShader;\n  this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms[\"opacity\"].value = 1.0;\n  this.materialCopy = new THREE.ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: THREE.AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this.oldClearColor = new THREE.Color();\n  this.oldClearAlpha = 1;\n  this.basic = new THREE.MeshBasicMaterial();\n  this.fsQuad = new THREE.Pass.FullScreenQuad(null);\n};\n\nTHREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n  constructor: THREE.UnrealBloomPass,\n  dispose: function () {\n    for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (var i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  },\n  setSize: function (width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    this.oldClearColor.copy(renderer.getClearColor());\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n    this.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n    this.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n    this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function (kernelRadius) {\n    return new THREE.ShaderMaterial({\n      defines: {\n        \"KERNEL_RADIUS\": kernelRadius,\n        \"SIGMA\": kernelRadius\n      },\n      uniforms: {\n        \"colorTexture\": {\n          value: null\n        },\n        \"texSize\": {\n          value: new THREE.Vector2(0.5, 0.5)\n        },\n        \"direction\": {\n          value: new THREE.Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: \"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\n      fragmentShader: \"#include <common>\\\r\n\t\t\t\tvarying vec2 vUv;\\n\\\r\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec2 direction;\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\r\n\t\t\t\t}\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\r\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\r\n\t\t\t\t\t\tfloat x = float(i);\\\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\r\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\r\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\r\n\t\t\t\t}\"\n    });\n  },\n  getCompositeMaterial: function (nMips) {\n    return new THREE.ShaderMaterial({\n      defines: {\n        \"NUM_MIPS\": nMips\n      },\n      uniforms: {\n        \"blurTexture1\": {\n          value: null\n        },\n        \"blurTexture2\": {\n          value: null\n        },\n        \"blurTexture3\": {\n          value: null\n        },\n        \"blurTexture4\": {\n          value: null\n        },\n        \"blurTexture5\": {\n          value: null\n        },\n        \"dirtTexture\": {\n          value: null\n        },\n        \"bloomStrength\": {\n          value: 1.0\n        },\n        \"bloomFactors\": {\n          value: null\n        },\n        \"bloomTintColors\": {\n          value: null\n        },\n        \"bloomRadius\": {\n          value: 0.0\n        }\n      },\n      vertexShader: \"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\n      fragmentShader: \"varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D blurTexture1;\\\r\n\t\t\t\tuniform sampler2D blurTexture2;\\\r\n\t\t\t\tuniform sampler2D blurTexture3;\\\r\n\t\t\t\tuniform sampler2D blurTexture4;\\\r\n\t\t\t\tuniform sampler2D blurTexture5;\\\r\n\t\t\t\tuniform sampler2D dirtTexture;\\\r\n\t\t\t\tuniform float bloomStrength;\\\r\n\t\t\t\tuniform float bloomRadius;\\\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\r\n\t\t\t\t}\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\r\n\t\t\t\t}\"\n    });\n  }\n});\nTHREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nTHREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\n//# sourceURL=webpack://COMGALLERY/./js/glsl/UnrealBloomPass.js?");

/***/ }),

/***/ "./js/glsl/index.js":
/*!**************************!*\
  !*** ./js/glsl/index.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _CopyShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CopyShader.js */ \"./js/glsl/CopyShader.js\");\n/* harmony import */ var _CopyShader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CopyShader_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectComposer.js */ \"./js/glsl/EffectComposer.js\");\n/* harmony import */ var _EffectComposer_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LuminosityHighPassShader.js */ \"./js/glsl/LuminosityHighPassShader.js\");\n/* harmony import */ var _LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _RenderPass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderPass.js */ \"./js/glsl/RenderPass.js\");\n/* harmony import */ var _RenderPass_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShaderPass.js */ \"./js/glsl/ShaderPass.js\");\n/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ShaderPass_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UnrealBloomPass.js */ \"./js/glsl/UnrealBloomPass.js\");\n/* harmony import */ var _UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _Poster_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Poster.js */ \"./js/glsl/Poster.js\");\n/* harmony import */ var _Poster_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_Poster_js__WEBPACK_IMPORTED_MODULE_6__);\n\n //import './FXAA.js';\n\n\n\n\n\n\n\n//# sourceURL=webpack://COMGALLERY/./js/glsl/index.js?");

/***/ }),

/***/ "./js/loader/FBXLoader.js":
/*!********************************!*\
  !*** ./js/loader/FBXLoader.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author Kyle-Larson https://github.com/Kyle-Larson\r\n * @author Takahiro https://github.com/takahirox\r\n *\r\n * Loader loads FBX file and generates Group representing FBX scene.\r\n * Requires FBX file to be >= 7.0 and in ASCII or to be any version in Binary format.\r\n *\r\n * Supports:\r\n * \tMesh Generation (Positional Data)\r\n * \tNormal Data (Per Vertex Drawing Instance)\r\n *\tUV Data (Per Vertex Drawing Instance)\r\n *\tSkinning\r\n *\tAnimation\r\n * \t- Separated Animations based on stacks.\r\n * \t- Skeletal & Non-Skeletal Animations\r\n *\tNURBS (Open, Closed and Periodic forms)\r\n *\r\n * Needs Support:\r\n * \tIndexed Buffers\r\n * \tPreRotation support.\r\n *\tEuler rotation order\r\n *\r\n * FBX format references:\r\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\r\n *\r\n * \tBinary format specification:\r\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\r\n *\t\thttps://wiki.rogiken.org/specifications/file-format/fbx/ (more detail but Japanese)\r\n *\r\n * Modifications\r\n * @author github.com/meatbags\r\n * Added support for Maya 2018 Stingray PBR Shaders -> MeshStandardMaterial\r\n */\n(function () {\n  THREE.FBXLoader = function (manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  };\n\n  Object.assign(THREE.FBXLoader.prototype, {\n    load: function (url, onLoad, onProgress, onError) {\n      var self = this; //var resourceDirectory = THREE.Loader.prototype.extractUrlBase( url );\n\n      var resourceDirectory = THREE.LoaderUtils.extractUrlBase(url);\n      var loader = new THREE.FileLoader(this.manager);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n        try {\n          var scene = self.parse(buffer, resourceDirectory);\n          onLoad(scene);\n        } catch (error) {\n          window.setTimeout(function () {\n            if (onError) onError(error);\n            self.manager.itemError(url);\n          }, 0);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (FBXBuffer, resourceDirectory) {\n      var FBXTree;\n\n      if (isFbxFormatBinary(FBXBuffer)) {\n        FBXTree = new BinaryParser().parse(FBXBuffer);\n      } else {\n        var FBXText = convertArrayBufferToString(FBXBuffer);\n\n        if (!isFbxFormatASCII(FBXText)) {\n          throw new Error('THREE.FBXLoader: Unknown format.');\n        }\n\n        if (getFbxVersion(FBXText) < 7000) {\n          throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n        }\n\n        FBXTree = new TextParser().parse(FBXText);\n      }\n\n      var connections = parseConnections(FBXTree);\n      var images = parseImages(FBXTree);\n      var textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);\n      var materials = parseMaterials(FBXTree, textures, connections);\n      var deformers = parseDeformers(FBXTree, connections);\n      var geometryMap = parseGeometries(FBXTree, connections, deformers);\n      var sceneGraph = parseScene(FBXTree, connections, deformers, geometryMap, materials);\n      return sceneGraph;\n    }\n  }); // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n\n  function parseConnections(FBXTree) {\n    var connectionMap = new Map();\n\n    if ('Connections' in FBXTree) {\n      var connectionArray = FBXTree.Connections.properties.connections;\n\n      for (var connectionArrayIndex = 0, connectionArrayLength = connectionArray.length; connectionArrayIndex < connectionArrayLength; ++connectionArrayIndex) {\n        var connection = connectionArray[connectionArrayIndex];\n\n        if (!connectionMap.has(connection[0])) {\n          connectionMap.set(connection[0], {\n            parents: [],\n            children: []\n          });\n        }\n\n        var parentRelationship = {\n          ID: connection[1],\n          relationship: connection[2]\n        };\n        connectionMap.get(connection[0]).parents.push(parentRelationship);\n\n        if (!connectionMap.has(connection[1])) {\n          connectionMap.set(connection[1], {\n            parents: [],\n            children: []\n          });\n        }\n\n        var childRelationship = {\n          ID: connection[0],\n          relationship: connection[2]\n        };\n        connectionMap.get(connection[1]).children.push(childRelationship);\n      }\n    }\n\n    return connectionMap;\n  } // Parses map of images referenced in FBXTree.Objects.subNodes.Video\n  // Images can either be referenced externally or embedded in the file\n  // These images are connected to textures in FBXTree.Objects.subNodes.Textures\n  // via FBXTree.Connections. Note that images can be duplicated here, in which case only one\n  // will will have a .Content field\n\n\n  function parseImages(FBXTree) {\n    var imageMap = new Map();\n\n    if ('Video' in FBXTree.Objects.subNodes) {\n      var videoNodes = FBXTree.Objects.subNodes.Video;\n\n      for (var nodeID in videoNodes) {\n        var videoNode = videoNodes[nodeID]; // raw image data is in videoNode.properties.Content\n\n        if ('Content' in videoNode.properties) {\n          var image = parseImage(videoNodes[nodeID]);\n          imageMap.set(parseInt(nodeID), image);\n        }\n      }\n    }\n\n    return imageMap;\n  } // Parse embedded image data in FBXTree.Video.properties.Content\n\n\n  function parseImage(videoNode) {\n    var content = videoNode.properties.Content;\n    var fileName = videoNode.properties.RelativeFilename || videoNode.properties.Filename;\n    var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n    var type;\n\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp';\n        break;\n\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg';\n        break;\n\n      case 'png':\n        type = 'image/png';\n        break;\n\n      case 'tif':\n        type = 'image/tiff';\n        break;\n\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n        return;\n    }\n\n    if (typeof content === 'string') {\n      return 'data:' + type + ';base64,' + content;\n    } else {\n      var array = new Uint8Array(content);\n      return window.URL.createObjectURL(new Blob([array], {\n        type: type\n      }));\n    }\n  } // Parse nodes in FBXTree.Objects.subNodes.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.subNodes.Video\n\n\n  function parseTextures(FBXTree, loader, imageMap, connections) {\n    var textureMap = new Map();\n    var extensionWhitelist = ['jpg', 'jpeg', 'png', 'bmp'];\n\n    if ('Texture' in FBXTree.Objects.subNodes) {\n      var textureNodes = FBXTree.Objects.subNodes.Texture;\n\n      for (var nodeID in textureNodes) {\n        var textureNode = textureNodes[nodeID];\n        var extension = textureNode.properties.FileName.slice(textureNode.properties.FileName.lastIndexOf('.') + 1).toLowerCase();\n\n        if (extensionWhitelist.indexOf(extension) != -1) {\n          var texture = parseTexture(textureNode, loader, imageMap, connections);\n          textureMap.set(parseInt(nodeID), texture);\n        }\n      }\n    }\n\n    return textureMap;\n  } // Parse individual node in FBXTree.Objects.subNodes.Texture\n\n\n  function parseTexture(textureNode, loader, imageMap, connections) {\n    var FBX_ID = textureNode.id;\n    var name = textureNode.attrName;\n    var fileName;\n    var filePath = textureNode.properties.FileName;\n    var relativeFilePath = textureNode.properties.RelativeFilename;\n    var children = connections.get(FBX_ID).children;\n\n    if (children !== undefined && children.length > 0 && imageMap.has(children[0].ID)) {\n      fileName = imageMap.get(children[0].ID);\n    } else if (relativeFilePath !== undefined && relativeFilePath[0] !== '/' && relativeFilePath.match(/^[a-zA-Z]:/) === null) {\n      // use textureNode.properties.RelativeFilename\n      // if it exists and it doesn't seem an absolute path\n      fileName = relativeFilePath;\n    } else {\n      var split = filePath.split(/[\\\\\\/]/);\n\n      if (split.length > 0) {\n        fileName = split[split.length - 1];\n      } else {\n        fileName = filePath;\n      }\n    }\n\n    var currentPath = loader.path;\n\n    if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n      loader.setPath(undefined);\n    }\n\n    var texture = loader.load(fileName);\n    texture.name = name;\n    texture.FBX_ID = FBX_ID;\n    var wrapModeU = textureNode.properties.WrapModeU;\n    var wrapModeV = textureNode.properties.WrapModeV;\n    var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n    var valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n    texture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n    if ('Scaling' in textureNode.properties) {\n      var values = textureNode.properties.Scaling.value;\n      texture.repeat.x = values[0];\n      texture.repeat.y = values[1];\n    }\n\n    loader.setPath(currentPath);\n    return texture;\n  } // Parse nodes in FBXTree.Objects.subNodes.Material\n\n\n  function parseMaterials(FBXTree, textureMap, connections) {\n    var materialMap = new Map();\n\n    if ('Material' in FBXTree.Objects.subNodes) {\n      var materialNodes = FBXTree.Objects.subNodes.Material;\n\n      for (var nodeID in materialNodes) {\n        var material = parseMaterial(materialNodes[nodeID], textureMap, connections);\n        if (material !== null) materialMap.set(parseInt(nodeID), material);\n      }\n    }\n\n    return materialMap;\n  } // Parse single node in FBXTree.Objects.subNodes.Material\n  // Materials are connected to texture maps in FBXTree.Objects.subNodes.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n\n\n  function parseMaterial(materialNode, textureMap, connections) {\n    //console.log('NODE', materialNode, textureMap, connections);\n    var FBX_ID = materialNode.id;\n    var name = materialNode.attrName;\n    var type = materialNode.properties.ShadingModel; // Case where FBX wraps shading model in property object.\n\n    if (typeof type === 'object') {\n      type = type.value;\n    } // Ignore unused materials which don't have any connections.\n\n\n    if (!connections.has(FBX_ID)) return null;\n    var children = connections.get(FBX_ID).children;\n    var parameters = parseParameters(materialNode.properties, textureMap, children);\n    var material;\n\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new THREE.MeshPhongMaterial();\n        break;\n\n      case 'lambert':\n        material = new THREE.MeshLambertMaterial();\n        break;\n\n      case 'unknown':\n        material = new THREE.MeshStandardMaterial();\n        break;\n\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n        material = new THREE.MeshPhongMaterial({\n          color: 0x3300ff\n        });\n        break;\n    }\n\n    material.setValues(parameters);\n    material.name = name;\n    return material;\n  } // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n\n\n  function parseParameters(properties, textureMap, childrenRelationships) {\n    var parameters = {};\n\n    if (properties.BumpFactor) {\n      parameters.bumpScale = properties.BumpFactor.value;\n    }\n\n    if (properties.Diffuse) {\n      parameters.color = parseColor(properties.Diffuse);\n    }\n\n    if (properties.DisplacementFactor) {\n      parameters.displacementScale = properties.DisplacementFactor.value;\n    }\n\n    if (properties.ReflectionFactor) {\n      parameters.reflectivity = properties.ReflectionFactor.value;\n    }\n\n    if (properties.Specular) {\n      parameters.specular = parseColor(properties.Specular);\n    }\n\n    if (properties.Shininess) {\n      parameters.shininess = properties.Shininess.value;\n    }\n\n    if (properties.Emissive) {\n      parameters.emissive = parseColor(properties.Emissive);\n    }\n\n    if (properties.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(properties.EmissiveFactor.value);\n    }\n\n    if (properties.Opacity) {\n      parameters.opacity = parseFloat(properties.Opacity.value);\n    }\n\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true;\n    } // Maya PBR export\n    //console.log(properties);\n\n\n    if (properties['Maya|base_color']) {\n      var c = properties['Maya|base_color'].value;\n      parameters.color = new THREE.Color(c[0], c[1], c[2]);\n    }\n\n    if (properties['Maya|emissive']) {\n      var c = properties['Maya|emissive'];\n      parameters.emissive = new THREE.Color(c[0], c[1], c[2]);\n    }\n\n    if (properties['Maya|emissive_intensity']) {\n      parameters.emissiveIntensity = properties['Maya|emissive_intensity'].value;\n    }\n\n    if (properties['Maya|metallic']) {\n      parameters.metalness = properties['Maya|metallic'].value;\n    }\n\n    if (properties['Maya|roughness']) {\n      parameters.roughness = properties['Maya|roughness'].value;\n    } // UV scale\n\n\n    var uvScale = 1;\n\n    if (properties['Maya|uv_scale']) {\n      var uvScale = properties['Maya|uv_scale'].value;\n    }\n\n    for (var childrenRelationshipsIndex = 0, childrenRelationshipsLength = childrenRelationships.length; childrenRelationshipsIndex < childrenRelationshipsLength; ++childrenRelationshipsIndex) {\n      var relationship = childrenRelationships[childrenRelationshipsIndex];\n      var type = relationship.relationship;\n\n      switch (type) {\n        // Maya PBR material exports\n        //case 'Maya|base_color':\n        case 'Maya|TEX_color_map':\n          var prop = 'Maya|use_color_map';\n\n          if (properties[prop] && properties[prop].value == 1) {\n            parameters.map = textureMap.get(relationship.ID);\n\n            if (uvScale != 1) {\n              parameters.map.wrapS = THREE.RepeatWrapping;\n              parameters.map.wrapT = THREE.RepeatWrapping;\n              parameters.map.repeat.set(uvScale, uvScale);\n            }\n          }\n\n          break;\n\n        case 'Maya|TEX_emissive_map':\n          var prop = 'Maya|use_emissive_map';\n\n          if (properties[prop] && properties[prop].value == 1) {\n            parameters.emissiveMap = textureMap.get(relationship.ID);\n\n            if (uvScale != 1) {\n              parameters.emissiveMap.wrapS = THREE.RepeatWrapping;\n              parameters.emissiveMap.wrapT = THREE.RepeatWrapping;\n              parameters.emissiveMap.repeat.set(uvScale, uvScale);\n            }\n          }\n\n          break;\n\n        case 'Maya|TEX_roughness_map':\n          var prop = 'Maya|use_roughness_map';\n\n          if (properties[prop] && properties[prop].value == 1) {\n            parameters.roughnessMap = textureMap.get(relationship.ID);\n\n            if (uvScale != 1) {\n              parameters.roughnessMap.wrapS = THREE.RepeatWrapping;\n              parameters.roughnessMap.wrapT = THREE.RepeatWrapping;\n              parameters.roughnessMap.repeat.set(uvScale, uvScale);\n            }\n          }\n\n          break;\n\n        case 'Maya|TEX_normal_map':\n          var prop = 'Maya|use_normal_map';\n\n          if (properties[prop] && properties[prop].value == 1) {\n            parameters.normalMap = textureMap.get(relationship.ID);\n\n            if (uvScale != 1) {\n              parameters.normalMap.wrapS = THREE.RepeatWrapping;\n              parameters.normalMap.wrapT = THREE.RepeatWrapping;\n              parameters.normalMap.repeat.set(uvScale, uvScale);\n            }\n          }\n\n          break;\n\n        case 'Maya|TEX_metallic_map':\n          var prop = 'Maya|use_metallic_map';\n\n          if (properties[prop] && properties[prop].value == 1) {\n            parameters.metalnessMap = textureMap.get(relationship.ID);\n\n            if (uvScale != 1) {\n              parameters.metalnessMap.wrapS = THREE.RepeatWrapping;\n              parameters.metalnessMap.wrapT = THREE.RepeatWrapping;\n              parameters.metalnessMap.repeat.set(uvScale, uvScale);\n            }\n          }\n\n          break;\n\n        case 'Maya|TEX_ao_map':\n          var prop = 'Maya|use_ao_map';\n\n          if (properties[prop] && properties[prop].value == 1) {\n            parameters.aoMap = textureMap.get(relationship.ID);\n\n            if (uvScale != 1) {\n              parameters.aoMap.wrapS = THREE.RepeatWrapping;\n              parameters.aoMap.wrapT = THREE.RepeatWrapping;\n              parameters.aoMap.repeat.set(uvScale, uvScale);\n            }\n          }\n\n          break;\n\n        case 'Maya|TEX_brdf_lut':\n        case 'Maya|TEX_global_specular_cube':\n        case 'Maya|TEX_global_diffuse_cube':\n          break;\n\n        case 'Bump':\n          parameters.bumpMap = textureMap.get(relationship.ID);\n          break;\n\n        case 'DiffuseColor':\n          parameters.map = textureMap.get(relationship.ID);\n          break;\n\n        case 'DisplacementColor':\n          parameters.displacementMap = textureMap.get(relationship.ID);\n          break;\n\n        case 'EmissiveColor':\n          parameters.emissiveMap = textureMap.get(relationship.ID);\n          break;\n\n        case 'NormalMap':\n          parameters.normalMap = textureMap.get(relationship.ID);\n          break;\n\n        case 'ReflectionColor':\n          parameters.envMap = textureMap.get(relationship.ID);\n          parameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n          break;\n\n        case 'SpecularColor':\n          parameters.specularMap = textureMap.get(relationship.ID);\n          break;\n\n        case 'TransparentColor':\n          parameters.alphaMap = textureMap.get(relationship.ID);\n          parameters.transparent = true;\n          break;\n\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n\n        case 'SpecularFactor': // AKA specularLevel\n\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n          break;\n      }\n    }\n\n    return parameters;\n  } // Parse nodes in FBXTree.Objects.subNodes.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\n\n  function parseDeformers(FBXTree, connections) {\n    var deformers = {};\n\n    if ('Deformer' in FBXTree.Objects.subNodes) {\n      var DeformerNodes = FBXTree.Objects.subNodes.Deformer;\n\n      for (var nodeID in DeformerNodes) {\n        var deformerNode = DeformerNodes[nodeID];\n\n        if (deformerNode.attrType === 'Skin') {\n          var conns = connections.get(parseInt(nodeID));\n          var skeleton = parseSkeleton(conns, DeformerNodes);\n          skeleton.FBX_ID = parseInt(nodeID);\n          deformers[nodeID] = skeleton;\n        }\n      }\n    }\n\n    return deformers;\n  } // Parse single nodes in FBXTree.Objects.subNodes.Deformer\n  // Generates a \"Skeleton Representation\" of FBX nodes based on an FBX Skin Deformer's connections\n  // and an object containing SubDeformer nodes.\n\n\n  function parseSkeleton(connections, DeformerNodes) {\n    var subDeformers = {};\n    var children = connections.children;\n\n    for (var i = 0, l = children.length; i < l; ++i) {\n      var child = children[i];\n      var subDeformerNode = DeformerNodes[child.ID];\n      var subDeformer = {\n        FBX_ID: child.ID,\n        index: i,\n        indices: [],\n        weights: [],\n        transform: new THREE.Matrix4().fromArray(subDeformerNode.subNodes.Transform.properties.a),\n        transformLink: new THREE.Matrix4().fromArray(subDeformerNode.subNodes.TransformLink.properties.a),\n        linkMode: subDeformerNode.properties.Mode\n      };\n\n      if ('Indexes' in subDeformerNode.subNodes) {\n        subDeformer.indices = subDeformerNode.subNodes.Indexes.properties.a;\n        subDeformer.weights = subDeformerNode.subNodes.Weights.properties.a;\n      }\n\n      subDeformers[child.ID] = subDeformer;\n    }\n\n    return {\n      map: subDeformers,\n      bones: []\n    };\n  } // Parse nodes in FBXTree.Objects.subNodes.Geometry\n\n\n  function parseGeometries(FBXTree, connections, deformers) {\n    var geometryMap = new Map();\n\n    if ('Geometry' in FBXTree.Objects.subNodes) {\n      var geometryNodes = FBXTree.Objects.subNodes.Geometry;\n\n      for (var nodeID in geometryNodes) {\n        var relationships = connections.get(parseInt(nodeID));\n        var geo = parseGeometry(geometryNodes[nodeID], relationships, deformers);\n        geometryMap.set(parseInt(nodeID), geo);\n      }\n    }\n\n    return geometryMap;\n  } // Parse single node in FBXTree.Objects.subNodes.Geometry\n\n\n  function parseGeometry(geometryNode, relationships, deformers) {\n    switch (geometryNode.attrType) {\n      case 'Mesh':\n        return parseMeshGeometry(geometryNode, relationships, deformers);\n        break;\n\n      case 'NurbsCurve':\n        return parseNurbsGeometry(geometryNode);\n        break;\n    }\n  } // Parse single node mesh geometry in FBXTree.Objects.subNodes.Geometry\n\n\n  function parseMeshGeometry(geometryNode, relationships, deformers) {\n    for (var i = 0; i < relationships.children.length; ++i) {\n      var deformer = deformers[relationships.children[i].ID];\n      if (deformer !== undefined) break;\n    }\n\n    return genGeometry(geometryNode, deformer);\n  } // Generate a THREE.BufferGeometry from a node in FBXTree.Objects.subNodes.Geometry\n\n\n  function genGeometry(geometryNode, deformer) {\n    var subNodes = geometryNode.subNodes;\n    var vertexPositions = subNodes.Vertices.properties.a;\n    var vertexIndices = subNodes.PolygonVertexIndex.properties.a; // create arrays to hold the final data used to build the buffergeometry\n\n    var vertexBuffer = [];\n    var normalBuffer = [];\n    var colorsBuffer = [];\n    var uvsBuffer = [];\n    var materialIndexBuffer = [];\n    var vertexWeightsBuffer = [];\n    var weightsIndicesBuffer = [];\n\n    if (subNodes.LayerElementColor) {\n      var colorInfo = getColors(subNodes.LayerElementColor[0]);\n    }\n\n    if (subNodes.LayerElementMaterial) {\n      var materialInfo = getMaterials(subNodes.LayerElementMaterial[0]);\n    }\n\n    if (subNodes.LayerElementNormal) {\n      var normalInfo = getNormals(subNodes.LayerElementNormal[0]);\n    }\n\n    if (subNodes.LayerElementUV) {\n      var uvInfo = [];\n      var i = 0;\n\n      while (subNodes.LayerElementUV[i]) {\n        uvInfo.push(getUVs(subNodes.LayerElementUV[i]));\n        i++;\n      }\n    }\n\n    var weightTable = {};\n\n    if (deformer) {\n      var subDeformers = deformer.map;\n\n      for (var key in subDeformers) {\n        var subDeformer = subDeformers[key];\n        var indices = subDeformer.indices;\n\n        for (var j = 0; j < indices.length; j++) {\n          var index = indices[j];\n          var weight = subDeformer.weights[j];\n          if (weightTable[index] === undefined) weightTable[index] = [];\n          weightTable[index].push({\n            id: subDeformer.index,\n            weight: weight\n          });\n        }\n      }\n    }\n\n    var polygonIndex = 0;\n    var faceLength = 0;\n    var displayedWeightsWarning = false; // these will hold data for a single face\n\n    var vertexPositionIndexes = [];\n    var faceNormals = [];\n    var faceColors = [];\n    var faceUVs = [];\n    var faceWeights = [];\n    var faceWeightIndices = [];\n\n    for (var polygonVertexIndex = 0; polygonVertexIndex < vertexIndices.length; polygonVertexIndex++) {\n      var vertexIndex = vertexIndices[polygonVertexIndex];\n      var endOfFace = false; // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex multiply by -1 and subtract 1: -3 * - 1 - 1 = 2\n\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\n        vertexIndices[polygonVertexIndex] = vertexIndex;\n        endOfFace = true;\n      }\n\n      var weightIndices = [];\n      var weights = [];\n      vertexPositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n      if (colorInfo) {\n        var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, colorInfo);\n        faceColors.push(data[0], data[1], data[2]);\n      }\n\n      if (deformer) {\n        if (weightTable[vertexIndex] !== undefined) {\n          var array = weightTable[vertexIndex];\n\n          for (var j = 0, jl = array.length; j < jl; j++) {\n            weights.push(array[j].weight);\n            weightIndices.push(array[j].id);\n          }\n        }\n\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n            displayedWeightsWarning = true;\n          }\n\n          var WIndex = [0, 0, 0, 0];\n          var Weight = [0, 0, 0, 0];\n          weights.forEach(function (weight, weightIndex) {\n            var currentWeight = weight;\n            var currentIndex = weightIndices[weightIndex];\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                currentWeight = comparedWeight;\n                var tmp = WIndex[comparedWeightIndex];\n                WIndex[comparedWeightIndex] = currentIndex;\n                currentIndex = tmp;\n              }\n            });\n          });\n          weightIndices = WIndex;\n          weights = Weight;\n        } // if the weight array is shorter than 4 pad with 0s\n\n\n        for (var i = weights.length; i < 4; ++i) {\n          weights[i] = 0;\n          weightIndices[i] = 0;\n        }\n\n        for (var i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i]);\n          faceWeightIndices.push(weightIndices[i]);\n        }\n      }\n\n      if (normalInfo) {\n        var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, normalInfo);\n        faceNormals.push(data[0], data[1], data[2]);\n      }\n\n      if (uvInfo) {\n        for (var i = 0; i < uvInfo.length; i++) {\n          var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uvInfo[i]);\n\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = [];\n          }\n\n          faceUVs[i].push(data[0], data[1]);\n        }\n      }\n\n      faceLength++; // we have reached the end of a face - it may have 4 sides though\n      // in which case the data is split into to represent 3 sides faces\n\n      if (endOfFace) {\n        for (var i = 2; i < faceLength; i++) {\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[0]]);\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[1]]);\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[2]]);\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[(i - 1) * 3]]);\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[(i - 1) * 3 + 1]]);\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[(i - 1) * 3 + 2]]);\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[i * 3]]);\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[i * 3 + 1]]);\n          vertexBuffer.push(vertexPositions[vertexPositionIndexes[i * 3 + 2]]);\n        }\n\n        if (deformer) {\n          for (var i = 2; i < faceLength; i++) {\n            vertexWeightsBuffer.push(faceWeights[0]);\n            vertexWeightsBuffer.push(faceWeights[1]);\n            vertexWeightsBuffer.push(faceWeights[2]);\n            vertexWeightsBuffer.push(faceWeights[3]);\n            vertexWeightsBuffer.push(faceWeights[(i - 1) * 4]);\n            vertexWeightsBuffer.push(faceWeights[(i - 1) * 4 + 1]);\n            vertexWeightsBuffer.push(faceWeights[(i - 1) * 4 + 2]);\n            vertexWeightsBuffer.push(faceWeights[(i - 1) * 4 + 3]);\n            vertexWeightsBuffer.push(faceWeights[i * 4]);\n            vertexWeightsBuffer.push(faceWeights[i * 4 + 1]);\n            vertexWeightsBuffer.push(faceWeights[i * 4 + 2]);\n            vertexWeightsBuffer.push(faceWeights[i * 4 + 3]);\n            weightsIndicesBuffer.push(faceWeightIndices[0]);\n            weightsIndicesBuffer.push(faceWeightIndices[1]);\n            weightsIndicesBuffer.push(faceWeightIndices[2]);\n            weightsIndicesBuffer.push(faceWeightIndices[3]);\n            weightsIndicesBuffer.push(faceWeightIndices[(i - 1) * 4]);\n            weightsIndicesBuffer.push(faceWeightIndices[(i - 1) * 4 + 1]);\n            weightsIndicesBuffer.push(faceWeightIndices[(i - 1) * 4 + 2]);\n            weightsIndicesBuffer.push(faceWeightIndices[(i - 1) * 4 + 3]);\n            weightsIndicesBuffer.push(faceWeightIndices[i * 4]);\n            weightsIndicesBuffer.push(faceWeightIndices[i * 4 + 1]);\n            weightsIndicesBuffer.push(faceWeightIndices[i * 4 + 2]);\n            weightsIndicesBuffer.push(faceWeightIndices[i * 4 + 3]);\n          }\n        }\n\n        if (normalInfo) {\n          for (var i = 2; i < faceLength; i++) {\n            normalBuffer.push(faceNormals[0]);\n            normalBuffer.push(faceNormals[1]);\n            normalBuffer.push(faceNormals[2]);\n            normalBuffer.push(faceNormals[(i - 1) * 3]);\n            normalBuffer.push(faceNormals[(i - 1) * 3 + 1]);\n            normalBuffer.push(faceNormals[(i - 1) * 3 + 2]);\n            normalBuffer.push(faceNormals[i * 3]);\n            normalBuffer.push(faceNormals[i * 3 + 1]);\n            normalBuffer.push(faceNormals[i * 3 + 2]);\n          }\n        }\n\n        if (uvInfo) {\n          for (var j = 0; j < uvInfo.length; j++) {\n            if (uvsBuffer[j] === undefined) uvsBuffer[j] = [];\n\n            for (var i = 2; i < faceLength; i++) {\n              uvsBuffer[j].push(faceUVs[j][0]);\n              uvsBuffer[j].push(faceUVs[j][1]);\n              uvsBuffer[j].push(faceUVs[j][(i - 1) * 2]);\n              uvsBuffer[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n              uvsBuffer[j].push(faceUVs[j][i * 2]);\n              uvsBuffer[j].push(faceUVs[j][i * 2 + 1]);\n            }\n          }\n        }\n\n        if (colorInfo) {\n          for (var i = 2; i < faceLength; i++) {\n            colorsBuffer.push(faceColors[0]);\n            colorsBuffer.push(faceColors[1]);\n            colorsBuffer.push(faceColors[2]);\n            colorsBuffer.push(faceColors[(i - 1) * 3]);\n            colorsBuffer.push(faceColors[(i - 1) * 3 + 1]);\n            colorsBuffer.push(faceColors[(i - 1) * 3 + 2]);\n            colorsBuffer.push(faceColors[i * 3]);\n            colorsBuffer.push(faceColors[i * 3 + 1]);\n            colorsBuffer.push(faceColors[i * 3 + 2]);\n          }\n        }\n\n        if (materialInfo && materialInfo.mappingType !== 'AllSame') {\n          var materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, materialInfo)[0];\n\n          for (var i = 2; i < faceLength; i++) {\n            materialIndexBuffer.push(materialIndex);\n            materialIndexBuffer.push(materialIndex);\n            materialIndexBuffer.push(materialIndex);\n          }\n        }\n\n        polygonIndex++;\n        endOfFace = false;\n        faceLength = 0; // reset arrays for the next face\n\n        vertexPositionIndexes = [];\n        faceNormals = [];\n        faceColors = [];\n        faceUVs = [];\n        faceWeights = [];\n        faceWeightIndices = [];\n      }\n    }\n\n    var geo = new THREE.BufferGeometry();\n    geo.name = geometryNode.name;\n    geo.addAttribute('position', new THREE.Float32BufferAttribute(vertexBuffer, 3));\n\n    if (colorsBuffer.length > 0) {\n      geo.addAttribute('color', new THREE.Float32BufferAttribute(colorsBuffer, 3));\n    }\n\n    if (deformer) {\n      geo.addAttribute('skinIndex', new THREE.Float32BufferAttribute(weightsIndicesBuffer, 4));\n      geo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(vertexWeightsBuffer, 4)); // used later to bind the skeleton to the model\n\n      geo.FBX_Deformer = deformer;\n    }\n\n    if (normalBuffer.length > 0) {\n      geo.addAttribute('normal', new THREE.Float32BufferAttribute(normalBuffer, 3));\n    }\n\n    if (uvsBuffer.length > 0) {\n      for (var i = 0; i < uvsBuffer.length; i++) {\n        var name = 'uv' + (i + 1).toString();\n\n        if (i == 0) {\n          name = 'uv';\n        }\n\n        geo.addAttribute(name, new THREE.Float32BufferAttribute(uvsBuffer[i], 2));\n      }\n    }\n\n    if (materialInfo && materialInfo.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      var prevMaterialIndex = materialIndexBuffer[0];\n      var startIndex = 0;\n\n      for (var i = 0; i < materialIndexBuffer.length; ++i) {\n        if (materialIndexBuffer[i] !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n          prevMaterialIndex = materialIndexBuffer[i];\n          startIndex = i;\n        }\n      } // the loop above doesn't add the last group, do that here.\n\n\n      if (geo.groups.length > 0) {\n        var lastGroup = geo.groups[geo.groups.length - 1];\n        var lastIndex = lastGroup.start + lastGroup.count;\n\n        if (lastIndex !== materialIndexBuffer.length) {\n          geo.addGroup(lastIndex, materialIndexBuffer.length - lastIndex, prevMaterialIndex);\n        }\n      } // case where there are multiple materials but the whole geometry is only\n      // using one of them\n\n\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, materialIndexBuffer.length, materialIndexBuffer[0]);\n      }\n    }\n\n    return geo;\n  } // Parse normal from FBXTree.Objects.subNodes.Geometry.subNodes.LayerElementNormal if it exists\n\n\n  function getNormals(NormalNode) {\n    var mappingType = NormalNode.properties.MappingInformationType;\n    var referenceType = NormalNode.properties.ReferenceInformationType;\n    var buffer = NormalNode.subNodes.Normals.properties.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode.subNodes) {\n        indexBuffer = NormalNode.subNodes.NormalIndex.properties.a;\n      } else if ('NormalsIndex' in NormalNode.subNodes) {\n        indexBuffer = NormalNode.subNodes.NormalsIndex.properties.a;\n      }\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse UVs from FBXTree.Objects.subNodes.Geometry.subNodes.LayerElementUV if it exists\n\n\n  function getUVs(UVNode) {\n    var mappingType = UVNode.properties.MappingInformationType;\n    var referenceType = UVNode.properties.ReferenceInformationType;\n    var buffer = UVNode.subNodes.UV.properties.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.subNodes.UVIndex.properties.a;\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse Vertex Colors from FBXTree.Objects.subNodes.Geometry.subNodes.LayerElementColor if it exists\n\n\n  function getColors(ColorNode) {\n    var mappingType = ColorNode.properties.MappingInformationType;\n    var referenceType = ColorNode.properties.ReferenceInformationType;\n    var buffer = ColorNode.subNodes.Colors.properties.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.subNodes.ColorIndex.properties.a;\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse mapping and material data in FBXTree.Objects.subNodes.Geometry.subNodes.LayerElementMaterial if it exists\n\n\n  function getMaterials(MaterialNode) {\n    var mappingType = MaterialNode.properties.MappingInformationType;\n    var referenceType = MaterialNode.properties.ReferenceInformationType;\n\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType\n      };\n    }\n\n    var materialIndexBuffer = MaterialNode.subNodes.Materials.properties.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n\n    var materialIndices = [];\n\n    for (var materialIndexBufferIndex = 0, materialIndexBufferLength = materialIndexBuffer.length; materialIndexBufferIndex < materialIndexBufferLength; ++materialIndexBufferIndex) {\n      materialIndices.push(materialIndexBufferIndex);\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Functions use the infoObject and given indices to return value array of geometry.\n  // infoObject can be materialInfo, normalInfo, UVInfo or colorInfo\n  // polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).\n  // polygonIndex - Index of polygon in geometry.\n  // vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).\n\n\n  var dataArray = [];\n  var GetData = {\n    ByPolygonVertex: {\n      Direct: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n        var from = polygonVertexIndex * infoObject.dataSize;\n        var to = polygonVertexIndex * infoObject.dataSize + infoObject.dataSize; // return infoObject.buffer.slice( from, to );\n\n        return slice(dataArray, infoObject.buffer, from, to);\n      },\n      IndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n        var index = infoObject.indices[polygonVertexIndex];\n        var from = index * infoObject.dataSize;\n        var to = index * infoObject.dataSize + infoObject.dataSize; // return infoObject.buffer.slice( from, to );\n\n        return slice(dataArray, infoObject.buffer, from, to);\n      }\n    },\n    ByPolygon: {\n      Direct: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n        var from = polygonIndex * infoObject.dataSize;\n        var to = polygonIndex * infoObject.dataSize + infoObject.dataSize; // return infoObject.buffer.slice( from, to );\n\n        return slice(dataArray, infoObject.buffer, from, to);\n      },\n      IndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n        var index = infoObject.indices[polygonIndex];\n        var from = index * infoObject.dataSize;\n        var to = index * infoObject.dataSize + infoObject.dataSize; // return infoObject.buffer.slice( from, to );\n\n        return slice(dataArray, infoObject.buffer, from, to);\n      }\n    },\n    ByVertice: {\n      Direct: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n        var from = vertexIndex * infoObject.dataSize;\n        var to = vertexIndex * infoObject.dataSize + infoObject.dataSize; // return infoObject.buffer.slice( from, to );\n\n        return slice(dataArray, infoObject.buffer, from, to);\n      }\n    },\n    AllSame: {\n      IndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n        var from = infoObject.indices[0] * infoObject.dataSize;\n        var to = infoObject.indices[0] * infoObject.dataSize + infoObject.dataSize; // return infoObject.buffer.slice( from, to );\n\n        return slice(dataArray, infoObject.buffer, from, to);\n      }\n    }\n  };\n\n  function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n    return GetData[infoObject.mappingType][infoObject.referenceType](polygonVertexIndex, polygonIndex, vertexIndex, infoObject);\n  } // Generate a NurbGeometry from a node in FBXTree.Objects.subNodes.Geometry\n\n\n  function parseNurbsGeometry(geometryNode) {\n    if (THREE.NURBSCurve === undefined) {\n      console.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n      return new THREE.BufferGeometry();\n    }\n\n    var order = parseInt(geometryNode.properties.Order);\n\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geometryNode.properties.Order, geometryNode.id);\n      return new THREE.BufferGeometry();\n    }\n\n    var degree = order - 1;\n    var knots = geometryNode.subNodes.KnotVector.properties.a;\n    var controlPoints = [];\n    var pointsValues = geometryNode.subNodes.Points.properties.a;\n\n    for (var i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n    }\n\n    var startKnot, endKnot;\n\n    if (geometryNode.properties.Form === 'Closed') {\n      controlPoints.push(controlPoints[0]);\n    } else if (geometryNode.properties.Form === 'Periodic') {\n      startKnot = degree;\n      endKnot = knots.length - 1 - startKnot;\n\n      for (var i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i]);\n      }\n    }\n\n    var curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n    var vertices = curve.getPoints(controlPoints.length * 7);\n    var positions = new Float32Array(vertices.length * 3);\n\n    for (var i = 0, l = vertices.length; i < l; ++i) {\n      vertices[i].toArray(positions, i * 3);\n    }\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n    return geometry;\n  } // parse nodes in FBXTree.Objects.subNodes.Model and generate a THREE.Group\n\n\n  function parseScene(FBXTree, connections, deformers, geometryMap, materialMap) {\n    var sceneGraph = new THREE.Group();\n    var ModelNode = FBXTree.Objects.subNodes.Model;\n    var modelArray = [];\n    var modelMap = new Map();\n\n    for (var nodeID in ModelNode) {\n      var id = parseInt(nodeID);\n      var node = ModelNode[nodeID];\n      var conns = connections.get(id);\n      var model = null;\n\n      for (var i = 0; i < conns.parents.length; ++i) {\n        for (var FBX_ID in deformers) {\n          var deformer = deformers[FBX_ID];\n          var subDeformers = deformer.map;\n          var subDeformer = subDeformers[conns.parents[i].ID];\n\n          if (subDeformer) {\n            var model2 = model;\n            model = new THREE.Bone();\n            deformer.bones[subDeformer.index] = model; // seems like we need this not to make non-connected bone, maybe?\n            // TODO: confirm\n\n            if (model2 !== null) model.add(model2);\n          }\n        }\n      }\n\n      if (!model) {\n        switch (node.attrType) {\n          // create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n          case 'Camera':\n            var cameraAttribute;\n\n            for (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n              var childID = conns.children[childrenIndex].ID;\n              var attr = FBXTree.Objects.subNodes.NodeAttribute[childID];\n\n              if (attr !== undefined && attr.properties !== undefined) {\n                cameraAttribute = attr.properties;\n              }\n            }\n\n            if (cameraAttribute === undefined) {\n              model = new THREE.Object3D();\n            } else {\n              var type = 0;\n\n              if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n                type = 1;\n              }\n\n              var nearClippingPlane = 1;\n\n              if (cameraAttribute.NearPlane !== undefined) {\n                nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n              }\n\n              var farClippingPlane = 1000;\n\n              if (cameraAttribute.FarPlane !== undefined) {\n                farClippingPlane = cameraAttribute.FarPlane.value / 1000;\n              }\n\n              var width = window.innerWidth;\n              var height = window.innerHeight;\n\n              if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n                width = cameraAttribute.AspectWidth.value;\n                height = cameraAttribute.AspectHeight.value;\n              }\n\n              var aspect = width / height;\n              var fov = 45;\n\n              if (cameraAttribute.FieldOfView !== undefined) {\n                fov = cameraAttribute.FieldOfView.value;\n              }\n\n              switch (type) {\n                case 0:\n                  // Perspective\n                  model = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n                  break;\n\n                case 1:\n                  // Orthographic\n                  model = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n                  break;\n\n                default:\n                  console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n                  model = new THREE.Object3D();\n                  break;\n              }\n            }\n\n            break;\n          // Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\n          case 'Light':\n            var lightAttribute;\n\n            for (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n              var childID = conns.children[childrenIndex].ID;\n              var attr = FBXTree.Objects.subNodes.NodeAttribute[childID];\n\n              if (attr !== undefined && attr.properties !== undefined) {\n                lightAttribute = attr.properties;\n              }\n            }\n\n            if (lightAttribute === undefined) {\n              model = new THREE.Object3D();\n            } else {\n              var type; // LightType can be undefined for Point lights\n\n              if (lightAttribute.LightType === undefined) {\n                type = 0;\n              } else {\n                type = lightAttribute.LightType.value;\n              }\n\n              var color = 0xffffff;\n\n              if (lightAttribute.Color !== undefined) {\n                color = parseColor(lightAttribute.Color.value);\n              }\n\n              var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100; // light disabled\n\n              if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n                intensity = 0;\n              }\n\n              var distance = 0;\n\n              if (lightAttribute.FarAttenuationEnd !== undefined) {\n                if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n                  distance = 0;\n                } else {\n                  distance = lightAttribute.FarAttenuationEnd.value / 1000;\n                }\n              } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\n\n              var decay = 1;\n\n              switch (type) {\n                case 0:\n                  // Point\n                  model = new THREE.PointLight(color, intensity, distance, decay);\n                  break;\n\n                case 1:\n                  // Directional\n                  model = new THREE.DirectionalLight(color, intensity);\n                  break;\n\n                case 2:\n                  // Spot\n                  var angle = Math.PI / 3;\n\n                  if (lightAttribute.InnerAngle !== undefined) {\n                    angle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);\n                  }\n\n                  var penumbra = 0;\n\n                  if (lightAttribute.OuterAngle !== undefined) {\n                    // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n                    // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n                    // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n                    penumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);\n                    penumbra = Math.max(penumbra, 1);\n                  }\n\n                  model = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);\n                  break;\n\n                default:\n                  console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');\n                  model = new THREE.PointLight(color, intensity);\n                  break;\n              }\n\n              if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n                model.castShadow = true;\n              }\n            }\n\n            break;\n\n          case 'Mesh':\n            var geometry = null;\n            var material = null;\n            var materials = [];\n\n            for (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n              var child = conns.children[childrenIndex];\n\n              if (geometryMap.has(child.ID)) {\n                geometry = geometryMap.get(child.ID);\n              }\n\n              if (materialMap.has(child.ID)) {\n                materials.push(materialMap.get(child.ID));\n              }\n            }\n\n            if (materials.length > 1) {\n              material = materials;\n            } else if (materials.length > 0) {\n              material = materials[0];\n            } else {\n              material = new THREE.MeshPhongMaterial({\n                color: 0xcccccc\n              });\n              materials.push(material);\n            }\n\n            if ('color' in geometry.attributes) {\n              for (var materialIndex = 0, numMaterials = materials.length; materialIndex < numMaterials; ++materialIndex) {\n                materials[materialIndex].vertexColors = THREE.VertexColors;\n              }\n            }\n\n            if (geometry.FBX_Deformer) {\n              for (var materialsIndex = 0, materialsLength = materials.length; materialsIndex < materialsLength; ++materialsIndex) {\n                materials[materialsIndex].skinning = true;\n              }\n\n              model = new THREE.SkinnedMesh(geometry, material);\n            } else {\n              model = new THREE.Mesh(geometry, material);\n            }\n\n            break;\n\n          case 'NurbsCurve':\n            var geometry = null;\n\n            for (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n              var child = conns.children[childrenIndex];\n\n              if (geometryMap.has(child.ID)) {\n                geometry = geometryMap.get(child.ID);\n              }\n            } // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\n\n            material = new THREE.LineBasicMaterial({\n              color: 0x3300ff,\n              linewidth: 5\n            });\n            model = new THREE.Line(geometry, material);\n            break;\n\n          default:\n            model = new THREE.Group();\n            break;\n        }\n      }\n\n      model.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);\n      model.FBX_ID = id;\n      modelArray.push(model);\n      modelMap.set(id, model);\n    }\n\n    for (var modelArrayIndex = 0, modelArrayLength = modelArray.length; modelArrayIndex < modelArrayLength; ++modelArrayIndex) {\n      var model = modelArray[modelArrayIndex];\n      var node = ModelNode[model.FBX_ID];\n\n      if ('Lcl_Translation' in node.properties) {\n        model.position.fromArray(node.properties.Lcl_Translation.value);\n      }\n\n      if ('Lcl_Rotation' in node.properties) {\n        var rotation = node.properties.Lcl_Rotation.value.map(THREE.Math.degToRad);\n        rotation.push('ZYX');\n        model.rotation.fromArray(rotation);\n      }\n\n      if ('Lcl_Scaling' in node.properties) {\n        model.scale.fromArray(node.properties.Lcl_Scaling.value);\n      }\n\n      if ('PreRotation' in node.properties) {\n        var array = node.properties.PreRotation.value.map(THREE.Math.degToRad);\n        array[3] = 'ZYX';\n        var preRotations = new THREE.Euler().fromArray(array);\n        preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n        var currentRotation = new THREE.Quaternion().setFromEuler(model.rotation);\n        preRotations.multiply(currentRotation);\n        model.rotation.setFromQuaternion(preRotations, 'ZYX');\n      } // allow transformed pivots - see https://github.com/mrdoob/three.js/issues/11895\n\n\n      if ('GeometricTranslation' in node.properties) {\n        var array = node.properties.GeometricTranslation.value;\n        model.traverse(function (child) {\n          if (child.geometry) {\n            child.geometry.translate(array[0], array[1], array[2]);\n          }\n        });\n      }\n\n      if ('LookAtProperty' in node.properties) {\n        var conns = connections.get(model.FBX_ID);\n\n        for (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n          var child = conns.children[childrenIndex];\n\n          if (child.relationship === 'LookAtProperty') {\n            var lookAtTarget = FBXTree.Objects.subNodes.Model[child.ID];\n\n            if ('Lcl_Translation' in lookAtTarget.properties) {\n              var pos = lookAtTarget.properties.Lcl_Translation.value; // DirectionalLight, SpotLight\n\n              if (model.target !== undefined) {\n                model.target.position.set(pos[0], pos[1], pos[2]);\n                sceneGraph.add(model.target);\n              } else {\n                // Cameras and other Object3Ds\n                model.lookAt(new THREE.Vector3(pos[0], pos[1], pos[2]));\n              }\n            }\n          }\n        }\n      }\n\n      var conns = connections.get(model.FBX_ID);\n\n      for (var parentIndex = 0; parentIndex < conns.parents.length; parentIndex++) {\n        var pIndex = findIndex(modelArray, function (mod) {\n          return mod.FBX_ID === conns.parents[parentIndex].ID;\n        });\n\n        if (pIndex > -1) {\n          modelArray[pIndex].add(model);\n          break;\n        }\n      }\n\n      if (model.parent === null) {\n        sceneGraph.add(model);\n      }\n    } // Now with the bones created, we can update the skeletons and bind them to the skinned meshes.\n\n\n    sceneGraph.updateMatrixWorld(true);\n    var worldMatrices = new Map(); // Put skeleton into bind pose.\n\n    if ('Pose' in FBXTree.Objects.subNodes) {\n      var BindPoseNode = FBXTree.Objects.subNodes.Pose;\n\n      for (var nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose') {\n          BindPoseNode = BindPoseNode[nodeID];\n          break;\n        }\n      }\n\n      var PoseNode = BindPoseNode.subNodes.PoseNode;\n\n      for (var PoseNodeIndex = 0, PoseNodeLength = PoseNode.length; PoseNodeIndex < PoseNodeLength; ++PoseNodeIndex) {\n        var node = PoseNode[PoseNodeIndex];\n        var rawMatWrd = new THREE.Matrix4().fromArray(node.subNodes.Matrix.properties.a);\n        worldMatrices.set(parseInt(node.properties.Node), rawMatWrd);\n      }\n    }\n\n    for (var FBX_ID in deformers) {\n      var deformer = deformers[FBX_ID];\n      var subDeformers = deformer.map;\n\n      for (var key in subDeformers) {\n        var subDeformer = subDeformers[key];\n        var subDeformerIndex = subDeformer.index;\n        var bone = deformer.bones[subDeformerIndex];\n\n        if (!worldMatrices.has(bone.FBX_ID)) {\n          break;\n        }\n\n        var mat = worldMatrices.get(bone.FBX_ID);\n        bone.matrixWorld.copy(mat);\n      } // Now that skeleton is in bind pose, bind to model.\n\n\n      deformer.skeleton = new THREE.Skeleton(deformer.bones);\n      var conns = connections.get(deformer.FBX_ID);\n      var parents = conns.parents;\n\n      for (var parentsIndex = 0, parentsLength = parents.length; parentsIndex < parentsLength; ++parentsIndex) {\n        var parent = parents[parentsIndex];\n\n        if (geometryMap.has(parent.ID)) {\n          var geoID = parent.ID;\n          var geoConns = connections.get(geoID);\n\n          for (var i = 0; i < geoConns.parents.length; ++i) {\n            if (modelMap.has(geoConns.parents[i].ID)) {\n              var model = modelMap.get(geoConns.parents[i].ID);\n              model.bind(deformer.skeleton, model.matrixWorld);\n              break;\n            }\n          }\n        }\n      }\n    } //Skeleton is now bound, return objects to starting world positions.\n\n\n    sceneGraph.updateMatrixWorld(true); // Silly hack with the animation parsing. We're gonna pretend the scene graph has a skeleton\n    // to attach animations to, since FBX treats animations as animations for the entire scene,\n    // not just for individual objects.\n\n    sceneGraph.skeleton = {\n      bones: modelArray\n    };\n    var animations = parseAnimations(FBXTree, connections, sceneGraph);\n    addAnimations(sceneGraph, animations); // Parse ambient color - if it's not set to black (default), create an ambient light\n\n    if ('GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings.properties) {\n      var ambientColor = FBXTree.GlobalSettings.properties.AmbientColor.value;\n      var r = ambientColor[0];\n      var g = ambientColor[1];\n      var b = ambientColor[2];\n\n      if (r !== 0 || g !== 0 || b !== 0) {\n        var color = new THREE.Color(r, g, b);\n        sceneGraph.add(new THREE.AmbientLight(color, 1));\n      }\n    }\n\n    return sceneGraph;\n  } // Parses animation information from nodes in\n  // FBXTree.Objects.subNodes.AnimationCurve ( connected to AnimationCurveNode )\n  // FBXTree.Objects.subNodes.AnimationCurveNode ( connected to AnimationLayer and an animated property in some other node )\n  // FBXTree.Objects.subNodes.AnimationLayer ( connected to AnimationStack )\n  // FBXTree.Objects.subNodes.AnimationStack\n\n\n  function parseAnimations(FBXTree, connections, sceneGraph) {\n    var rawNodes = FBXTree.Objects.subNodes.AnimationCurveNode;\n    var rawCurves = FBXTree.Objects.subNodes.AnimationCurve;\n    var rawLayers = FBXTree.Objects.subNodes.AnimationLayer;\n    var rawStacks = FBXTree.Objects.subNodes.AnimationStack;\n    var fps = 30; // default framerate\n\n    if ('GlobalSettings' in FBXTree && 'TimeMode' in FBXTree.GlobalSettings.properties) {\n      /* Autodesk time mode documentation can be found here:\r\n      *\thttp://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/class_fbx_time.html,topicNumber=cpp_ref_class_fbx_time_html\r\n      */\n      var timeModeEnum = [30, // 0: eDefaultMode\n      120, // 1: eFrames120\n      100, // 2: eFrames100\n      60, // 3: eFrames60\n      50, // 4: eFrames50\n      48, // 5: eFrames48\n      30, // 6: eFrames30 (black and white NTSC )\n      30, // 7: eFrames30Drop\n      29.97, // 8: eNTSCDropFrame\n      29.97, // 90: eNTSCFullFrame\n      25, // 10: ePal ( PAL/SECAM )\n      24, // 11: eFrames24 (Film/Cinema)\n      1, // 12: eFrames1000 (use for date time))\n      23.976, // 13: eFilmFullFrame\n      30, // 14: eCustom: use GlobalSettings.properties.CustomFrameRate.value\n      96, // 15: eFrames96\n      72, // 16: eFrames72\n      59.94];\n      var eMode = FBXTree.GlobalSettings.properties.TimeMode.value;\n\n      if (eMode === 14) {\n        if ('CustomFrameRate' in FBXTree.GlobalSettings.properties) {\n          fps = FBXTree.GlobalSettings.properties.CustomFrameRate.value;\n          fps = fps === -1 ? 30 : fps;\n        }\n      } else if (eMode <= 17) {\n        // for future proofing - if more eModes get added, they will default to 30fps\n        fps = timeModeEnum[eMode];\n      }\n    }\n\n    var returnObject = {\n      curves: new Map(),\n      layers: {},\n      stacks: {},\n      length: 0,\n      fps: fps,\n      frames: 0\n    };\n    var animationCurveNodes = [];\n\n    for (var nodeID in rawNodes) {\n      if (nodeID.match(/\\d+/)) {\n        var animationNode = parseAnimationNode(FBXTree, rawNodes[nodeID], connections, sceneGraph);\n        animationCurveNodes.push(animationNode);\n      }\n    }\n\n    var tmpMap = new Map();\n\n    for (var animationCurveNodeIndex = 0; animationCurveNodeIndex < animationCurveNodes.length; ++animationCurveNodeIndex) {\n      if (animationCurveNodes[animationCurveNodeIndex] === null) {\n        continue;\n      }\n\n      tmpMap.set(animationCurveNodes[animationCurveNodeIndex].id, animationCurveNodes[animationCurveNodeIndex]);\n    }\n\n    var animationCurves = [];\n\n    for (nodeID in rawCurves) {\n      if (nodeID.match(/\\d+/)) {\n        var animationCurve = parseAnimationCurve(rawCurves[nodeID]); // seems like this check would be necessary?\n\n        if (!connections.has(animationCurve.id)) continue;\n        animationCurves.push(animationCurve);\n        var firstParentConn = connections.get(animationCurve.id).parents[0];\n        var firstParentID = firstParentConn.ID;\n        var firstParentRelationship = firstParentConn.relationship;\n        var axis = '';\n\n        if (firstParentRelationship.match(/X/)) {\n          axis = 'x';\n        } else if (firstParentRelationship.match(/Y/)) {\n          axis = 'y';\n        } else if (firstParentRelationship.match(/Z/)) {\n          axis = 'z';\n        } else {\n          continue;\n        }\n\n        tmpMap.get(firstParentID).curves[axis] = animationCurve;\n      }\n    }\n\n    tmpMap.forEach(function (curveNode) {\n      var id = curveNode.containerBoneID;\n\n      if (!returnObject.curves.has(id)) {\n        returnObject.curves.set(id, {\n          T: null,\n          R: null,\n          S: null\n        });\n      }\n\n      returnObject.curves.get(id)[curveNode.attr] = curveNode;\n\n      if (curveNode.attr === 'R') {\n        var curves = curveNode.curves; // Some FBX files have an AnimationCurveNode\n        // which isn't any connected to any AnimationCurve.\n        // Setting animation parameter for them here.\n\n        if (curves.x === null) {\n          curves.x = {\n            version: null,\n            times: [0.0],\n            values: [0.0]\n          };\n        }\n\n        if (curves.y === null) {\n          curves.y = {\n            version: null,\n            times: [0.0],\n            values: [0.0]\n          };\n        }\n\n        if (curves.z === null) {\n          curves.z = {\n            version: null,\n            times: [0.0],\n            values: [0.0]\n          };\n        }\n\n        curves.x.values = curves.x.values.map(THREE.Math.degToRad);\n        curves.y.values = curves.y.values.map(THREE.Math.degToRad);\n        curves.z.values = curves.z.values.map(THREE.Math.degToRad);\n\n        if (curveNode.preRotations !== null) {\n          var preRotations = new THREE.Euler().setFromVector3(curveNode.preRotations, 'ZYX');\n          preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n          var frameRotation = new THREE.Euler();\n          var frameRotationQuaternion = new THREE.Quaternion();\n\n          for (var frame = 0; frame < curves.x.times.length; ++frame) {\n            frameRotation.set(curves.x.values[frame], curves.y.values[frame], curves.z.values[frame], 'ZYX');\n            frameRotationQuaternion.setFromEuler(frameRotation).premultiply(preRotations);\n            frameRotation.setFromQuaternion(frameRotationQuaternion, 'ZYX');\n            curves.x.values[frame] = frameRotation.x;\n            curves.y.values[frame] = frameRotation.y;\n            curves.z.values[frame] = frameRotation.z;\n          }\n        }\n      }\n    });\n\n    for (var nodeID in rawLayers) {\n      var layer = [];\n      var children = connections.get(parseInt(nodeID)).children;\n\n      for (var childIndex = 0; childIndex < children.length; childIndex++) {\n        // Skip lockInfluenceWeights\n        if (tmpMap.has(children[childIndex].ID)) {\n          var curveNode = tmpMap.get(children[childIndex].ID);\n          var boneID = curveNode.containerBoneID;\n\n          if (layer[boneID] === undefined) {\n            layer[boneID] = {\n              T: null,\n              R: null,\n              S: null\n            };\n          }\n\n          layer[boneID][curveNode.attr] = curveNode;\n        }\n      }\n\n      returnObject.layers[nodeID] = layer;\n    }\n\n    for (var nodeID in rawStacks) {\n      var layers = [];\n      var children = connections.get(parseInt(nodeID)).children;\n      var timestamps = {\n        max: 0,\n        min: Number.MAX_VALUE\n      };\n\n      for (var childIndex = 0; childIndex < children.length; ++childIndex) {\n        var currentLayer = returnObject.layers[children[childIndex].ID];\n\n        if (currentLayer !== undefined) {\n          layers.push(currentLayer);\n\n          for (var currentLayerIndex = 0, currentLayerLength = currentLayer.length; currentLayerIndex < currentLayerLength; ++currentLayerIndex) {\n            var layer = currentLayer[currentLayerIndex];\n\n            if (layer) {\n              getCurveNodeMaxMinTimeStamps(layer, timestamps);\n            }\n          }\n        }\n      } // Do we have an animation clip with actual length?\n\n\n      if (timestamps.max > timestamps.min) {\n        returnObject.stacks[nodeID] = {\n          name: rawStacks[nodeID].attrName,\n          layers: layers,\n          length: timestamps.max - timestamps.min,\n          frames: (timestamps.max - timestamps.min) * returnObject.fps\n        };\n      }\n    }\n\n    return returnObject;\n  }\n\n  function parseAnimationNode(FBXTree, animationCurveNode, connections, sceneGraph) {\n    var rawModels = FBXTree.Objects.subNodes.Model;\n    var returnObject = {\n      id: animationCurveNode.id,\n      attr: animationCurveNode.attrName,\n      internalID: animationCurveNode.id,\n      attrX: false,\n      attrY: false,\n      attrZ: false,\n      containerBoneID: -1,\n      containerID: -1,\n      curves: {\n        x: null,\n        y: null,\n        z: null\n      },\n      preRotations: null\n    };\n\n    if (returnObject.attr.match(/S|R|T/)) {\n      for (var attributeKey in animationCurveNode.properties) {\n        if (attributeKey.match(/X/)) {\n          returnObject.attrX = true;\n        }\n\n        if (attributeKey.match(/Y/)) {\n          returnObject.attrY = true;\n        }\n\n        if (attributeKey.match(/Z/)) {\n          returnObject.attrZ = true;\n        }\n      }\n    } else {\n      return null;\n    }\n\n    var conns = connections.get(returnObject.id);\n    var containerIndices = conns.parents;\n\n    for (var containerIndicesIndex = containerIndices.length - 1; containerIndicesIndex >= 0; --containerIndicesIndex) {\n      var boneID = findIndex(sceneGraph.skeleton.bones, function (bone) {\n        return bone.FBX_ID === containerIndices[containerIndicesIndex].ID;\n      });\n\n      if (boneID > -1) {\n        returnObject.containerBoneID = boneID;\n        returnObject.containerID = containerIndices[containerIndicesIndex].ID;\n        var model = rawModels[returnObject.containerID.toString()];\n\n        if ('PreRotation' in model.properties) {\n          returnObject.preRotations = parseVector3(model.properties.PreRotation).multiplyScalar(Math.PI / 180);\n        }\n\n        break;\n      }\n    }\n\n    return returnObject;\n  }\n\n  function parseAnimationCurve(animationCurve) {\n    return {\n      version: null,\n      id: animationCurve.id,\n      internalID: animationCurve.id,\n      times: animationCurve.subNodes.KeyTime.properties.a.map(convertFBXTimeToSeconds),\n      values: animationCurve.subNodes.KeyValueFloat.properties.a,\n      attrFlag: animationCurve.subNodes.KeyAttrFlags.properties.a,\n      attrData: animationCurve.subNodes.KeyAttrDataFloat.properties.a\n    };\n  } // Sets the maxTimeStamp and minTimeStamp variables if it has timeStamps that are either larger or smaller\n  // than the max or min respectively.\n\n\n  function getCurveNodeMaxMinTimeStamps(layer, timestamps) {\n    if (layer.R) {\n      getCurveMaxMinTimeStamp(layer.R.curves, timestamps);\n    }\n\n    if (layer.S) {\n      getCurveMaxMinTimeStamp(layer.S.curves, timestamps);\n    }\n\n    if (layer.T) {\n      getCurveMaxMinTimeStamp(layer.T.curves, timestamps);\n    }\n  } // Sets the maxTimeStamp and minTimeStamp if one of the curve's time stamps\n  // exceeds the maximum or minimum.\n\n\n  function getCurveMaxMinTimeStamp(curve, timestamps) {\n    if (curve.x) {\n      getCurveAxisMaxMinTimeStamps(curve.x, timestamps);\n    }\n\n    if (curve.y) {\n      getCurveAxisMaxMinTimeStamps(curve.y, timestamps);\n    }\n\n    if (curve.z) {\n      getCurveAxisMaxMinTimeStamps(curve.z, timestamps);\n    }\n  } // Sets the maxTimeStamp and minTimeStamp if one of its timestamps exceeds the maximum or minimum.\n\n\n  function getCurveAxisMaxMinTimeStamps(axis, timestamps) {\n    timestamps.max = axis.times[axis.times.length - 1] > timestamps.max ? axis.times[axis.times.length - 1] : timestamps.max;\n    timestamps.min = axis.times[0] < timestamps.min ? axis.times[0] : timestamps.min;\n  }\n\n  function addAnimations(group, animations) {\n    if (group.animations === undefined) {\n      group.animations = [];\n    }\n\n    var stacks = animations.stacks;\n\n    for (var key in stacks) {\n      var stack = stacks[key];\n      var animationData = {\n        name: stack.name,\n        fps: animations.fps,\n        length: stack.length,\n        hierarchy: []\n      };\n      var bones = group.skeleton.bones;\n\n      for (var bonesIndex = 0, bonesLength = bones.length; bonesIndex < bonesLength; ++bonesIndex) {\n        var bone = bones[bonesIndex];\n        var name = bone.name.replace(/.*:/, '');\n        var parentIndex = findIndex(bones, function (parentBone) {\n          return bone.parent === parentBone;\n        });\n        animationData.hierarchy.push({\n          parent: parentIndex,\n          name: name,\n          keys: []\n        });\n      }\n\n      for (var frame = 0; frame <= stack.frames; frame++) {\n        for (var bonesIndex = 0, bonesLength = bones.length; bonesIndex < bonesLength; ++bonesIndex) {\n          var bone = bones[bonesIndex];\n          var boneIndex = bonesIndex;\n          var animationNode = stack.layers[0][boneIndex];\n\n          for (var hierarchyIndex = 0, hierarchyLength = animationData.hierarchy.length; hierarchyIndex < hierarchyLength; ++hierarchyIndex) {\n            var node = animationData.hierarchy[hierarchyIndex];\n\n            if (node.name === bone.name) {\n              node.keys.push(generateKey(animations, animationNode, bone, frame));\n            }\n          }\n        }\n      }\n\n      group.animations.push(THREE.AnimationClip.parseAnimation(animationData, bones));\n    }\n  }\n\n  var euler = new THREE.Euler();\n  var quaternion = new THREE.Quaternion();\n\n  function generateKey(animations, animationNode, bone, frame) {\n    var key = {\n      time: frame / animations.fps,\n      pos: bone.position.toArray(),\n      rot: bone.quaternion.toArray(),\n      scl: bone.scale.toArray()\n    };\n    if (animationNode === undefined) return key;\n    euler.setFromQuaternion(bone.quaternion, 'ZYX', false);\n\n    try {\n      if (hasCurve(animationNode, 'T') && hasKeyOnFrame(animationNode.T, frame)) {\n        if (animationNode.T.curves.x.values[frame]) {\n          key.pos[0] = animationNode.T.curves.x.values[frame];\n        }\n\n        if (animationNode.T.curves.y.values[frame]) {\n          key.pos[1] = animationNode.T.curves.y.values[frame];\n        }\n\n        if (animationNode.T.curves.z.values[frame]) {\n          key.pos[2] = animationNode.T.curves.z.values[frame];\n        }\n      }\n\n      if (hasCurve(animationNode, 'R') && hasKeyOnFrame(animationNode.R, frame)) {\n        // Only update the euler's values if rotation is defined for the axis on this frame\n        if (animationNode.R.curves.x.values[frame]) {\n          euler.x = animationNode.R.curves.x.values[frame];\n        }\n\n        if (animationNode.R.curves.y.values[frame]) {\n          euler.y = animationNode.R.curves.y.values[frame];\n        }\n\n        if (animationNode.R.curves.z.values[frame]) {\n          euler.z = animationNode.R.curves.z.values[frame];\n        }\n\n        quaternion.setFromEuler(euler);\n        key.rot = quaternion.toArray();\n      }\n\n      if (hasCurve(animationNode, 'S') && hasKeyOnFrame(animationNode.S, frame)) {\n        if (animationNode.T.curves.x.values[frame]) {\n          key.scl[0] = animationNode.S.curves.x.values[frame];\n        }\n\n        if (animationNode.T.curves.y.values[frame]) {\n          key.scl[1] = animationNode.S.curves.y.values[frame];\n        }\n\n        if (animationNode.T.curves.z.values[frame]) {\n          key.scl[2] = animationNode.S.curves.z.values[frame];\n        }\n      }\n    } catch (error) {\n      // Curve is not fully plotted.\n      console.log('THREE.FBXLoader: ', bone);\n      console.log('THREE.FBXLoader: ', error);\n    }\n\n    return key;\n  }\n\n  var AXES = ['x', 'y', 'z'];\n\n  function hasCurve(animationNode, attribute) {\n    if (animationNode === undefined) {\n      return false;\n    }\n\n    var attributeNode = animationNode[attribute];\n\n    if (!attributeNode) {\n      return false;\n    }\n\n    return AXES.every(function (key) {\n      return attributeNode.curves[key] !== null;\n    });\n  }\n\n  function hasKeyOnFrame(attributeNode, frame) {\n    return AXES.every(function (key) {\n      return isKeyExistOnFrame(attributeNode.curves[key], frame);\n    });\n  }\n\n  function isKeyExistOnFrame(curve, frame) {\n    return curve.values[frame] !== undefined;\n  } // parse an FBX file in ASCII format\n\n\n  function TextParser() {}\n\n  Object.assign(TextParser.prototype, {\n    getPrevNode: function () {\n      return this.nodeStack[this.currentIndent - 2];\n    },\n    getCurrentNode: function () {\n      return this.nodeStack[this.currentIndent - 1];\n    },\n    getCurrentProp: function () {\n      return this.currentProp;\n    },\n    pushStack: function (node) {\n      this.nodeStack.push(node);\n      this.currentIndent += 1;\n    },\n    popStack: function () {\n      this.nodeStack.pop();\n      this.currentIndent -= 1;\n    },\n    setCurrentProp: function (val, name) {\n      this.currentProp = val;\n      this.currentPropName = name;\n    },\n    parse: function (text) {\n      this.currentIndent = 0;\n      this.allNodes = new FBXTree();\n      this.nodeStack = [];\n      this.currentProp = [];\n      this.currentPropName = '';\n      var split = text.split('\\n');\n\n      for (var lineNum = 0, lineLength = split.length; lineNum < lineLength; lineNum++) {\n        var l = split[lineNum]; // skip comment line\n\n        if (l.match(/^[\\s\\t]*;/)) {\n          continue;\n        } // skip empty line\n\n\n        if (l.match(/^[\\s\\t]*$/)) {\n          continue;\n        } // beginning of node\n\n\n        var beginningOfNodeExp = new RegExp('^\\\\t{' + this.currentIndent + '}(\\\\w+):(.*){', '');\n        var match = l.match(beginningOfNodeExp);\n\n        if (match) {\n          var nodeName = match[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n          var nodeAttrs = match[2].split(',');\n\n          for (var i = 0, l = nodeAttrs.length; i < l; i++) {\n            nodeAttrs[i] = nodeAttrs[i].trim().replace(/^\"/, '').replace(/\"$/, '');\n          }\n\n          this.parseNodeBegin(l, nodeName, nodeAttrs || null);\n          continue;\n        } // node's property\n\n\n        var propExp = new RegExp('^\\\\t{' + this.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n        var match = l.match(propExp);\n\n        if (match) {\n          var propName = match[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n          var propValue = match[2].replace(/^\"/, '').replace(/\"$/, '').trim(); // for special case: base64 image data follows \"Content: ,\" line\n          //\tContent: ,\n          //\t \"iVB...\"\n\n          if (propName === 'Content' && propValue === ',') {\n            propValue = split[++lineNum].replace(/\"/g, '').replace(/,$/, '').trim();\n          }\n\n          this.parseNodeProperty(l, propName, propValue);\n          continue;\n        } // end of node\n\n\n        var endOfNodeExp = new RegExp('^\\\\t{' + (this.currentIndent - 1) + '}}');\n\n        if (l.match(endOfNodeExp)) {\n          this.nodeEnd();\n          continue;\n        } // large arrays are split over multiple lines terminated with a ',' character\n        // if this is encountered the line needs to be joined to the previous line\n\n\n        if (l.match(/^[^\\s\\t}]/)) {\n          this.parseNodePropertyContinued(l);\n        }\n      }\n\n      return this.allNodes;\n    },\n    parseNodeBegin: function (line, nodeName, nodeAttrs) {\n      var node = {\n        'name': nodeName,\n        properties: {},\n        'subNodes': {}\n      };\n      var attrs = this.parseNodeAttr(nodeAttrs);\n      var currentNode = this.getCurrentNode(); // a top node\n\n      if (this.currentIndent === 0) {\n        this.allNodes.add(nodeName, node);\n      } else {\n        // a subnode\n        // if the subnode already exists, append it\n        if (nodeName in currentNode.subNodes) {\n          var tmp = currentNode.subNodes[nodeName];\n\n          if (this.isFlattenNode(currentNode.subNodes[nodeName])) {\n            if (attrs.id === '') {\n              currentNode.subNodes[nodeName] = [];\n              currentNode.subNodes[nodeName].push(tmp);\n            } else {\n              currentNode.subNodes[nodeName] = {};\n              currentNode.subNodes[nodeName][tmp.id] = tmp;\n            }\n          }\n\n          if (attrs.id === '') {\n            currentNode.subNodes[nodeName].push(node);\n          } else {\n            currentNode.subNodes[nodeName][attrs.id] = node;\n          }\n        } else if (typeof attrs.id === 'number' || attrs.id.match(/^\\d+$/)) {\n          currentNode.subNodes[nodeName] = {};\n          currentNode.subNodes[nodeName][attrs.id] = node;\n        } else {\n          currentNode.subNodes[nodeName] = node;\n        }\n      } // for this\t↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n      // NodeAttribute: 1001463072, \"NodeAttribute::\", \"LimbNode\" {\n\n\n      if (nodeAttrs) {\n        node.id = attrs.id;\n        node.attrName = attrs.name;\n        node.attrType = attrs.type;\n      }\n\n      this.pushStack(node);\n    },\n    parseNodeAttr: function (attrs) {\n      var id = attrs[0];\n\n      if (attrs[0] !== '') {\n        id = parseInt(attrs[0]);\n\n        if (isNaN(id)) {\n          id = attrs[0];\n        }\n      }\n\n      var name = '',\n          type = '';\n\n      if (attrs.length > 1) {\n        name = attrs[1].replace(/^(\\w+)::/, '');\n        type = attrs[2];\n      }\n\n      return {\n        id: id,\n        name: name,\n        type: type\n      };\n    },\n    parseNodeProperty: function (line, propName, propValue) {\n      var currentNode = this.getCurrentNode();\n      var parentName = currentNode.name; // special case where the parent node is something like \"Properties70\"\n      // these children nodes must treated carefully\n\n      if (parentName !== undefined) {\n        var propMatch = parentName.match(/Properties(\\d)+/);\n\n        if (propMatch) {\n          this.parseNodeSpecialProperty(line, propName, propValue);\n          return;\n        }\n      } // Connections\n\n\n      if (propName === 'C') {\n        var connProps = propValue.split(',').slice(1);\n        var from = parseInt(connProps[0]);\n        var to = parseInt(connProps[1]);\n        var rest = propValue.split(',').slice(3);\n        rest = rest.map(function (elem) {\n          return elem.trim().replace(/^\"/, '');\n        });\n        propName = 'connections';\n        propValue = [from, to];\n        append(propValue, rest);\n\n        if (currentNode.properties[propName] === undefined) {\n          currentNode.properties[propName] = [];\n        }\n      } // Node\n\n\n      if (propName === 'Node') {\n        var id = parseInt(propValue);\n        currentNode.properties.id = id;\n        currentNode.id = id;\n      } // already exists in properties, then append this\n\n\n      if (propName in currentNode.properties) {\n        if (Array.isArray(currentNode.properties[propName])) {\n          currentNode.properties[propName].push(propValue);\n        } else {\n          currentNode.properties[propName] += propValue;\n        }\n      } else {\n        if (Array.isArray(currentNode.properties[propName])) {\n          currentNode.properties[propName].push(propValue);\n        } else {\n          currentNode.properties[propName] = propValue;\n        }\n      }\n\n      this.setCurrentProp(currentNode.properties, propName); // convert string to array, unless it ends in ',' in which case more will be added to it\n\n      if (propName === 'a' && propValue.slice(-1) !== ',') {\n        currentNode.properties.a = parseNumberArray(propValue);\n      }\n    },\n    parseNodePropertyContinued: function (line) {\n      this.currentProp[this.currentPropName] += line; // if the line doesn't end in ',' we have reached the end of the property value\n      // so convert the string to an array\n\n      if (line.slice(-1) !== ',') {\n        var currentNode = this.getCurrentNode();\n        currentNode.properties.a = parseNumberArray(currentNode.properties.a);\n      }\n    },\n    parseNodeSpecialProperty: function (line, propName, propValue) {\n      // split this\n      // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n      // into array like below\n      // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n      var props = propValue.split('\",');\n\n      for (var i = 0, l = props.length; i < l; i++) {\n        props[i] = props[i].trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n      }\n\n      var innerPropName = props[0];\n      var innerPropType1 = props[1];\n      var innerPropType2 = props[2];\n      var innerPropFlag = props[3];\n      var innerPropValue = props[4]; // cast value to its type\n\n      switch (innerPropType1) {\n        case 'int':\n        case 'enum':\n        case 'bool':\n        case 'ULongLong':\n          innerPropValue = parseInt(innerPropValue);\n          break;\n\n        case 'double':\n        case 'Number':\n        case 'FieldOfView':\n          innerPropValue = parseFloat(innerPropValue);\n          break;\n\n        case 'ColorRGB':\n        case 'Vector3D':\n        case 'Lcl_Translation':\n        case 'Lcl_Rotation':\n        case 'Lcl_Scaling':\n          innerPropValue = parseNumberArray(innerPropValue);\n          break;\n      } // CAUTION: these props must append to parent's parent\n\n\n      this.getPrevNode().properties[innerPropName] = {\n        'type': innerPropType1,\n        'type2': innerPropType2,\n        'flag': innerPropFlag,\n        'value': innerPropValue\n      };\n      this.setCurrentProp(this.getPrevNode().properties, innerPropName);\n    },\n    nodeEnd: function () {\n      this.popStack();\n    },\n    isFlattenNode: function (node) {\n      return 'subNodes' in node && 'properties' in node ? true : false;\n    }\n  }); // Parse an FBX file in Binary format\n\n  function BinaryParser() {}\n\n  Object.assign(BinaryParser.prototype, {\n    parse: function (buffer) {\n      var reader = new BinaryReader(buffer);\n      reader.skip(23); // skip magic 23 bytes\n\n      var version = reader.getUint32(); //console.log( 'THREE.FBXLoader: FBX binary version: ' + version );\n\n      var allNodes = new FBXTree();\n      var count = 0;\n\n      while (!this.endOfContent(reader)) {\n        try {\n          var node = this.parseNode(reader, version);\n\n          if (node !== null) {\n            allNodes.add(node.name, node);\n          }\n        } catch (err) {\n          console.log(err);\n        }\n      }\n\n      return allNodes;\n    },\n    // Check if reader has reached the end of content.\n    endOfContent: function (reader) {\n      // footer size: 160bytes + 16-byte alignment padding\n      // - 16bytes: magic\n      // - padding til 16-byte alignment (at least 1byte?)\n      //\t(seems like some exporters embed fixed 15 or 16bytes?)\n      // - 4bytes: magic\n      // - 4bytes: version\n      // - 120bytes: zero\n      // - 16bytes: magic\n      if (reader.size() % 16 === 0) {\n        return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n      } else {\n        return reader.getOffset() + 160 + 16 >= reader.size();\n      }\n    },\n    parseNode: function (reader, version) {\n      // The first three data sizes depends on version.\n      var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32(); // note: do not remove this even if you get a linter warning as it moves the buffer forward\n\n      var propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var nameLen = reader.getUint8();\n      var name = reader.getString(nameLen); // Regards this node as NULL-record if endOffset is zero\n\n      if (endOffset === 0) return null;\n      var propertyList = [];\n\n      for (var i = 0; i < numProperties; i++) {\n        propertyList.push(this.parseProperty(reader));\n      } // Regards the first three elements in propertyList as id, attrName, and attrType\n\n\n      var id = propertyList.length > 0 ? propertyList[0] : '';\n      var attrName = propertyList.length > 1 ? propertyList[1] : '';\n      var attrType = propertyList.length > 2 ? propertyList[2] : '';\n      var subNodes = {};\n      var properties = {};\n      var isSingleProperty = false; // check if this node represents just a single property\n      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\n      if (numProperties === 1 && reader.getOffset() === endOffset) {\n        isSingleProperty = true;\n      }\n\n      while (endOffset > reader.getOffset()) {\n        var node = this.parseNode(reader, version);\n        if (node === null) continue; // special case: child node is single property\n\n        if (node.singleProperty === true) {\n          var value = node.propertyList[0];\n\n          if (Array.isArray(value)) {\n            subNodes[node.name] = node;\n            node.properties.a = value;\n          } else {\n            properties[node.name] = value;\n          }\n\n          continue;\n        } // parse connections\n\n\n        if (name === 'Connections' && node.name === 'C') {\n          var array = [];\n\n          for (var i = 1, il = node.propertyList.length; i < il; i++) {\n            array[i - 1] = node.propertyList[i];\n          }\n\n          if (properties.connections === undefined) {\n            properties.connections = [];\n          }\n\n          properties.connections.push(array);\n          continue;\n        } // special case: child node is Properties\\d+\n        // move child node's properties to this node.\n\n\n        if (node.name.match(/^Properties\\d+$/)) {\n          var keys = Object.keys(node.properties);\n\n          for (var i = 0, il = keys.length; i < il; i++) {\n            var key = keys[i];\n            properties[key] = node.properties[key];\n          }\n\n          continue;\n        } // parse 'properties70'\n\n\n        if (name.match(/^Properties\\d+$/) && node.name === 'P') {\n          var innerPropName = node.propertyList[0];\n          var innerPropType1 = node.propertyList[1];\n          var innerPropType2 = node.propertyList[2];\n          var innerPropFlag = node.propertyList[3];\n          var innerPropValue;\n          if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n          if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n          if (innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n            innerPropValue = [node.propertyList[4], node.propertyList[5], node.propertyList[6]];\n          } else {\n            innerPropValue = node.propertyList[4];\n          } // this will be copied to parent, see above\n\n\n          properties[innerPropName] = {\n            'type': innerPropType1,\n            'type2': innerPropType2,\n            'flag': innerPropFlag,\n            'value': innerPropValue\n          };\n          continue;\n        }\n\n        if (subNodes[node.name] === undefined) {\n          if (typeof node.id === 'number') {\n            subNodes[node.name] = {};\n            subNodes[node.name][node.id] = node;\n          } else {\n            subNodes[node.name] = node;\n          }\n        } else {\n          if (node.id === '') {\n            if (!Array.isArray(subNodes[node.name])) {\n              subNodes[node.name] = [subNodes[node.name]];\n            }\n\n            subNodes[node.name].push(node);\n          } else {\n            if (subNodes[node.name][node.id] === undefined) {\n              subNodes[node.name][node.id] = node;\n            } else {\n              // conflict id. irregular?\n              if (!Array.isArray(subNodes[node.name][node.id])) {\n                subNodes[node.name][node.id] = [subNodes[node.name][node.id]];\n              }\n\n              subNodes[node.name][node.id].push(node);\n            }\n          }\n        }\n      }\n\n      return {\n        singleProperty: isSingleProperty,\n        id: id,\n        attrName: attrName,\n        attrType: attrType,\n        name: name,\n        properties: properties,\n        propertyList: propertyList,\n        // raw property list used by parent\n        subNodes: subNodes\n      };\n    },\n    parseProperty: function (reader) {\n      var type = reader.getChar();\n\n      switch (type) {\n        case 'C':\n          return reader.getBoolean();\n\n        case 'D':\n          return reader.getFloat64();\n\n        case 'F':\n          return reader.getFloat32();\n\n        case 'I':\n          return reader.getInt32();\n\n        case 'L':\n          return reader.getInt64();\n\n        case 'R':\n          var length = reader.getUint32();\n          return reader.getArrayBuffer(length);\n\n        case 'S':\n          var length = reader.getUint32();\n          return reader.getString(length);\n\n        case 'Y':\n          return reader.getInt16();\n\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'f':\n        case 'i':\n        case 'l':\n          var arrayLength = reader.getUint32();\n          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\n          var compressedLength = reader.getUint32();\n\n          if (encoding === 0) {\n            switch (type) {\n              case 'b':\n              case 'c':\n                return reader.getBooleanArray(arrayLength);\n\n              case 'd':\n                return reader.getFloat64Array(arrayLength);\n\n              case 'f':\n                return reader.getFloat32Array(arrayLength);\n\n              case 'i':\n                return reader.getInt32Array(arrayLength);\n\n              case 'l':\n                return reader.getInt64Array(arrayLength);\n            }\n          }\n\n          if (window.Zlib === undefined) {\n            throw new Error('THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js');\n          }\n\n          var inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\n          var reader2 = new BinaryReader(inflate.decompress().buffer);\n\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader2.getBooleanArray(arrayLength);\n\n            case 'd':\n              return reader2.getFloat64Array(arrayLength);\n\n            case 'f':\n              return reader2.getFloat32Array(arrayLength);\n\n            case 'i':\n              return reader2.getInt32Array(arrayLength);\n\n            case 'l':\n              return reader2.getInt64Array(arrayLength);\n          }\n\n        default:\n          throw new Error('THREE.FBXLoader: Unknown property type ' + type);\n      }\n    }\n  });\n\n  function BinaryReader(buffer, littleEndian) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n  }\n\n  Object.assign(BinaryReader.prototype, {\n    getOffset: function () {\n      return this.offset;\n    },\n    size: function () {\n      return this.dv.buffer.byteLength;\n    },\n    skip: function (length) {\n      this.offset += length;\n    },\n    // seems like true/false representation depends on exporter.\n    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n    // then sees LSB.\n    getBoolean: function () {\n      return (this.getUint8() & 1) === 1;\n    },\n    getBooleanArray: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getBoolean());\n      }\n\n      return a;\n    },\n    getInt8: function () {\n      var value = this.dv.getInt8(this.offset);\n      this.offset += 1;\n      return value;\n    },\n    getInt8Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt8());\n      }\n\n      return a;\n    },\n    getUint8: function () {\n      var value = this.dv.getUint8(this.offset);\n      this.offset += 1;\n      return value;\n    },\n    getUint8Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getUint8());\n      }\n\n      return a;\n    },\n    getInt16: function () {\n      var value = this.dv.getInt16(this.offset, this.littleEndian);\n      this.offset += 2;\n      return value;\n    },\n    getInt16Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt16());\n      }\n\n      return a;\n    },\n    getUint16: function () {\n      var value = this.dv.getUint16(this.offset, this.littleEndian);\n      this.offset += 2;\n      return value;\n    },\n    getUint16Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getUint16());\n      }\n\n      return a;\n    },\n    getInt32: function () {\n      var value = this.dv.getInt32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getInt32Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt32());\n      }\n\n      return a;\n    },\n    getUint32: function () {\n      var value = this.dv.getUint32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getUint32Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getUint32());\n      }\n\n      return a;\n    },\n    // JavaScript doesn't support 64-bit integer so calculate this here\n    // 1 << 32 will return 1 so using multiply operation instead here.\n    // There's a possibility that this method returns wrong value if the value\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n    // TODO: safely handle 64-bit integer\n    getInt64: function () {\n      var low, high;\n\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      } // calculate negative value\n\n\n      if (high & 0x80000000) {\n        high = ~high & 0xFFFFFFFF;\n        low = ~low & 0xFFFFFFFF;\n        if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n        low = low + 1 & 0xFFFFFFFF;\n        return -(high * 0x100000000 + low);\n      }\n\n      return high * 0x100000000 + low;\n    },\n    getInt64Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt64());\n      }\n\n      return a;\n    },\n    // Note: see getInt64() comment\n    getUint64: function () {\n      var low, high;\n\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      }\n\n      return high * 0x100000000 + low;\n    },\n    getUint64Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getUint64());\n      }\n\n      return a;\n    },\n    getFloat32: function () {\n      var value = this.dv.getFloat32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getFloat32Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat32());\n      }\n\n      return a;\n    },\n    getFloat64: function () {\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\n      this.offset += 8;\n      return value;\n    },\n    getFloat64Array: function (size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat64());\n      }\n\n      return a;\n    },\n    getArrayBuffer: function (size) {\n      var value = this.dv.buffer.slice(this.offset, this.offset + size);\n      this.offset += size;\n      return value;\n    },\n    getChar: function () {\n      return String.fromCharCode(this.getUint8());\n    },\n    getString: function (size) {\n      var s = '';\n\n      while (size > 0) {\n        var value = this.getUint8();\n        size--;\n        if (value === 0) break;\n        s += String.fromCharCode(value);\n      } // Manage UTF8 encoding\n\n\n      s = decodeURIComponent(escape(s));\n      this.skip(size);\n      return s;\n    }\n  }); // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n  // and BinaryParser( FBX Binary format)\n\n  function FBXTree() {}\n\n  Object.assign(FBXTree.prototype, {\n    add: function (key, val) {\n      this[key] = val;\n    }\n  });\n\n  function isFbxFormatBinary(buffer) {\n    var CORRECT = 'Kaydara FBX Binary  \\0';\n    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n  }\n\n  function isFbxFormatASCII(text) {\n    var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n    var cursor = 0;\n\n    function read(offset) {\n      var result = text[offset - 1];\n      text = text.slice(cursor + offset);\n      cursor++;\n      return result;\n    }\n\n    for (var i = 0; i < CORRECT.length; ++i) {\n      var num = read(1);\n\n      if (num === CORRECT[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getFbxVersion(text) {\n    var versionRegExp = /FBXVersion: (\\d+)/;\n    var match = text.match(versionRegExp);\n\n    if (match) {\n      var version = parseInt(match[1]);\n      return version;\n    }\n\n    throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n  } // Converts FBX ticks into real time seconds.\n\n\n  function convertFBXTimeToSeconds(time) {\n    return time / 46186158000;\n  } // Parses comma separated list of numbers and returns them an array.\n  // Used internally by the TextParser\n\n\n  function parseNumberArray(value) {\n    var array = value.split(',');\n\n    for (var i = 0, l = array.length; i < l; i++) {\n      array[i] = parseFloat(array[i]);\n    }\n\n    return array;\n  }\n\n  function parseVector3(property) {\n    return new THREE.Vector3().fromArray(property.value);\n  }\n\n  function parseColor(property) {\n    return new THREE.Color().fromArray(property.value);\n  } // Converts ArrayBuffer to String.\n\n\n  function convertArrayBufferToString(buffer, from, to) {\n    if (from === undefined) from = 0;\n    if (to === undefined) to = buffer.byteLength;\n    var array = new Uint8Array(buffer, from, to);\n\n    if (window.TextDecoder !== undefined) {\n      return new TextDecoder().decode(array);\n    }\n\n    var s = '';\n\n    for (var i = 0, il = array.length; i < il; i++) {\n      s += String.fromCharCode(array[i]);\n    }\n\n    return s;\n  }\n\n  function findIndex(array, func) {\n    for (var i = 0, l = array.length; i < l; i++) {\n      if (func(array[i])) return i;\n    }\n\n    return -1;\n  }\n\n  function append(a, b) {\n    for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n      a[j] = b[i];\n    }\n  }\n\n  function slice(a, b, from, to) {\n    for (var i = from, j = 0; i < to; i++, j++) {\n      a[j] = b[i];\n    }\n\n    return a;\n  }\n})();\n\n//# sourceURL=webpack://COMGALLERY/./js/loader/FBXLoader.js?");

/***/ }),

/***/ "./js/loader/OBJLoader.js":
/*!********************************!*\
  !*** ./js/loader/OBJLoader.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\nTHREE.OBJLoader = function () {\n  // o object_name | g group_name\n  var object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference\n\n  var material_library_pattern = /^mtllib /; // usemtl material_name\n\n  var material_use_pattern = /^usemtl /;\n\n  function ParserState() {\n    var state = {\n      objects: [],\n      object: {},\n      vertices: [],\n      normals: [],\n      colors: [],\n      uvs: [],\n      materialLibraries: [],\n      startObject: function (name, fromDeclaration) {\n        // If the current object (initial from reset) is not from a g/o declaration in the parsed\n        // file. We need to use it for the first parsed g/o to keep things in sync.\n        if (this.object && this.object.fromDeclaration === false) {\n          this.object.name = name;\n          this.object.fromDeclaration = fromDeclaration !== false;\n          return;\n        }\n\n        var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n        if (this.object && typeof this.object._finalize === 'function') {\n          this.object._finalize(true);\n        }\n\n        this.object = {\n          name: name || '',\n          fromDeclaration: fromDeclaration !== false,\n          geometry: {\n            vertices: [],\n            normals: [],\n            colors: [],\n            uvs: []\n          },\n          materials: [],\n          smooth: true,\n          startMaterial: function (name, libraries) {\n            var previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared\n            // after the material, then it must be preserved for proper MultiMaterial continuation.\n\n\n            if (previous && (previous.inherited || previous.groupCount <= 0)) {\n              this.materials.splice(previous.index, 1);\n            }\n\n            var material = {\n              index: this.materials.length,\n              name: name || '',\n              mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n              smooth: previous !== undefined ? previous.smooth : this.smooth,\n              groupStart: previous !== undefined ? previous.groupEnd : 0,\n              groupEnd: -1,\n              groupCount: -1,\n              inherited: false,\n              clone: function (index) {\n                var cloned = {\n                  index: typeof index === 'number' ? index : this.index,\n                  name: this.name,\n                  mtllib: this.mtllib,\n                  smooth: this.smooth,\n                  groupStart: 0,\n                  groupEnd: -1,\n                  groupCount: -1,\n                  inherited: false\n                };\n                cloned.clone = this.clone.bind(cloned);\n                return cloned;\n              }\n            };\n            this.materials.push(material);\n            return material;\n          },\n          currentMaterial: function () {\n            if (this.materials.length > 0) {\n              return this.materials[this.materials.length - 1];\n            }\n\n            return undefined;\n          },\n          _finalize: function (end) {\n            var lastMultiMaterial = this.currentMaterial();\n\n            if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n              lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n              lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n              lastMultiMaterial.inherited = false;\n            } // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\n\n            if (end && this.materials.length > 1) {\n              for (var mi = this.materials.length - 1; mi >= 0; mi--) {\n                if (this.materials[mi].groupCount <= 0) {\n                  this.materials.splice(mi, 1);\n                }\n              }\n            } // Guarantee at least one empty material, this makes the creation later more straight forward.\n\n\n            if (end && this.materials.length === 0) {\n              this.materials.push({\n                name: '',\n                smooth: this.smooth\n              });\n            }\n\n            return lastMultiMaterial;\n          }\n        }; // Inherit previous objects material.\n        // Spec tells us that a declared material must be set to all objects until a new material is declared.\n        // If a usemtl declaration is encountered while this new object is being parsed, it will\n        // overwrite the inherited material. Exception being that there was already face declarations\n        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n        if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n          var declared = previousMaterial.clone(0);\n          declared.inherited = true;\n          this.object.materials.push(declared);\n        }\n\n        this.objects.push(this.object);\n      },\n      finalize: function () {\n        if (this.object && typeof this.object._finalize === 'function') {\n          this.object._finalize(true);\n        }\n      },\n      parseVertexIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n      },\n      parseNormalIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 3) * 3;\n      },\n      parseUVIndex: function (value, len) {\n        var index = parseInt(value, 10);\n        return (index >= 0 ? index - 1 : index + len / 2) * 2;\n      },\n      addVertex: function (a, b, c) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addVertexPoint: function (a) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      },\n      addVertexLine: function (a) {\n        var src = this.vertices;\n        var dst = this.object.geometry.vertices;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      },\n      addNormal: function (a, b, c) {\n        var src = this.normals;\n        var dst = this.object.geometry.normals;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addColor: function (a, b, c) {\n        var src = this.colors;\n        var dst = this.object.geometry.colors;\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n      },\n      addUV: function (a, b, c) {\n        var src = this.uvs;\n        var dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n        dst.push(src[b + 0], src[b + 1]);\n        dst.push(src[c + 0], src[c + 1]);\n      },\n      addUVLine: function (a) {\n        var src = this.uvs;\n        var dst = this.object.geometry.uvs;\n        dst.push(src[a + 0], src[a + 1]);\n      },\n      addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n        var vLen = this.vertices.length;\n        var ia = this.parseVertexIndex(a, vLen);\n        var ib = this.parseVertexIndex(b, vLen);\n        var ic = this.parseVertexIndex(c, vLen);\n        this.addVertex(ia, ib, ic);\n\n        if (ua !== undefined && ua !== '') {\n          var uvLen = this.uvs.length;\n          ia = this.parseUVIndex(ua, uvLen);\n          ib = this.parseUVIndex(ub, uvLen);\n          ic = this.parseUVIndex(uc, uvLen);\n          this.addUV(ia, ib, ic);\n        }\n\n        if (na !== undefined && na !== '') {\n          // Normals are many times the same. If so, skip function call and parseInt.\n          var nLen = this.normals.length;\n          ia = this.parseNormalIndex(na, nLen);\n          ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n          ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n          this.addNormal(ia, ib, ic);\n        }\n\n        if (this.colors.length > 0) {\n          this.addColor(ia, ib, ic);\n        }\n      },\n      addPointGeometry: function (vertices) {\n        this.object.geometry.type = 'Points';\n        var vLen = this.vertices.length;\n\n        for (var vi = 0, l = vertices.length; vi < l; vi++) {\n          this.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));\n        }\n      },\n      addLineGeometry: function (vertices, uvs) {\n        this.object.geometry.type = 'Line';\n        var vLen = this.vertices.length;\n        var uvLen = this.uvs.length;\n\n        for (var vi = 0, l = vertices.length; vi < l; vi++) {\n          this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n        }\n\n        for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {\n          this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n        }\n      }\n    };\n    state.startObject('', false);\n    return state;\n  } //\n\n\n  function OBJLoader(manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n    this.materials = null;\n  }\n\n  OBJLoader.prototype = {\n    constructor: OBJLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.load(url, function (text) {\n        onLoad(scope.parse(text));\n      }, onProgress, onError);\n    },\n    setPath: function (value) {\n      this.path = value;\n      return this;\n    },\n    setMaterials: function (materials) {\n      this.materials = materials;\n      return this;\n    },\n    parse: function (text) {\n      console.time('OBJLoader');\n      var state = new ParserState();\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      if (text.indexOf('\\\\\\n') !== -1) {\n        // join lines separated by a line continuation character (\\)\n        text = text.replace(/\\\\\\n/g, '');\n      }\n\n      var lines = text.split('\\n');\n      var line = '',\n          lineFirstChar = '';\n      var lineLength = 0;\n      var result = []; // Faster to just trim left side of the line. Use if available.\n\n      var trimLeft = typeof ''.trimLeft === 'function';\n\n      for (var i = 0, l = lines.length; i < l; i++) {\n        line = lines[i];\n        line = trimLeft ? line.trimLeft() : line.trim();\n        lineLength = line.length;\n        if (lineLength === 0) continue;\n        lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any\n\n        if (lineFirstChar === '#') continue;\n\n        if (lineFirstChar === 'v') {\n          var data = line.split(/\\s+/);\n\n          switch (data[0]) {\n            case 'v':\n              state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\n              if (data.length === 8) {\n                state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n              }\n\n              break;\n\n            case 'vn':\n              state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n              break;\n\n            case 'vt':\n              state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n              break;\n          }\n        } else if (lineFirstChar === 'f') {\n          var lineData = line.substr(1).trim();\n          var vertexData = lineData.split(/\\s+/);\n          var faceVertices = []; // Parse the face vertex data into an easy to work with format\n\n          for (var j = 0, jl = vertexData.length; j < jl; j++) {\n            var vertex = vertexData[j];\n\n            if (vertex.length > 0) {\n              var vertexParts = vertex.split('/');\n              faceVertices.push(vertexParts);\n            }\n          } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\n          var v1 = faceVertices[0];\n\n          for (var j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n            var v2 = faceVertices[j];\n            var v3 = faceVertices[j + 1];\n            state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n          }\n        } else if (lineFirstChar === 'l') {\n          var lineParts = line.substring(1).trim().split(\" \");\n          var lineVertices = [],\n              lineUVs = [];\n\n          if (line.indexOf(\"/\") === -1) {\n            lineVertices = lineParts;\n          } else {\n            for (var li = 0, llen = lineParts.length; li < llen; li++) {\n              var parts = lineParts[li].split(\"/\");\n              if (parts[0] !== \"\") lineVertices.push(parts[0]);\n              if (parts[1] !== \"\") lineUVs.push(parts[1]);\n            }\n          }\n\n          state.addLineGeometry(lineVertices, lineUVs);\n        } else if (lineFirstChar === 'p') {\n          var lineData = line.substr(1).trim();\n          var pointData = lineData.split(\" \");\n          state.addPointGeometry(pointData);\n        } else if ((result = object_pattern.exec(line)) !== null) {\n          // o object_name\n          // or\n          // g group_name\n          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n          // var name = result[ 0 ].substr( 1 ).trim();\n          var name = (\" \" + result[0].substr(1).trim()).substr(1);\n          state.startObject(name);\n        } else if (material_use_pattern.test(line)) {\n          // material\n          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n        } else if (material_library_pattern.test(line)) {\n          // mtl file\n          state.materialLibraries.push(line.substring(7).trim());\n        } else if (lineFirstChar === 's') {\n          result = line.split(' '); // smooth shading\n          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n          // but does not define a usemtl for each face set.\n          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n          // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n          // where explicit usemtl defines geometry groups.\n          // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n          /*\r\n           * http://paulbourke.net/dataformats/obj/\r\n           * or\r\n           * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\r\n           *\r\n           * From chapter \"Grouping\" Syntax explanation \"s group_number\":\r\n           * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\r\n           * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\r\n           * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\r\n           * than 0.\"\r\n           */\n\n          if (result.length > 1) {\n            var value = result[1].trim().toLowerCase();\n            state.object.smooth = value !== '0' && value !== 'off';\n          } else {\n            // ZBrush can produce \"s\" lines #11707\n            state.object.smooth = true;\n          }\n\n          var material = state.object.currentMaterial();\n          if (material) material.smooth = state.object.smooth;\n        } else {\n          // Handle null terminated files without exception\n          if (line === '\\0') continue;\n          throw new Error('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n        }\n      }\n\n      state.finalize();\n      var container = new THREE.Group();\n      container.materialLibraries = [].concat(state.materialLibraries);\n\n      for (var i = 0, l = state.objects.length; i < l; i++) {\n        var object = state.objects[i];\n        var geometry = object.geometry;\n        var materials = object.materials;\n        var isLine = geometry.type === 'Line';\n        var isPoints = geometry.type === 'Points';\n        var hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces\n\n        if (geometry.vertices.length === 0) continue;\n        var buffergeometry = new THREE.BufferGeometry();\n        buffergeometry.addAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));\n\n        if (geometry.normals.length > 0) {\n          buffergeometry.addAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\n        } else {\n          buffergeometry.computeVertexNormals();\n        }\n\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true;\n          buffergeometry.addAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));\n        }\n\n        if (geometry.uvs.length > 0) {\n          buffergeometry.addAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));\n        } // Create materials\n\n\n        var createdMaterials = [];\n\n        for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          var sourceMaterial = materials[mi];\n          var material = undefined;\n\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\n            if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n              var materialLine = new THREE.LineBasicMaterial();\n              materialLine.copy(material);\n              materialLine.lights = false; // TOFIX\n\n              material = materialLine;\n            } else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {\n              var materialPoints = new THREE.PointsMaterial({\n                size: 10,\n                sizeAttenuation: false\n              });\n              materialLine.copy(material);\n              material = materialPoints;\n            }\n          }\n\n          if (!material) {\n            if (isLine) {\n              material = new THREE.LineBasicMaterial();\n            } else if (isPoints) {\n              material = new THREE.PointsMaterial({\n                size: 1,\n                sizeAttenuation: false\n              });\n            } else {\n              material = new THREE.MeshPhongMaterial();\n            }\n\n            material.name = sourceMaterial.name;\n          }\n\n          material.flatShading = sourceMaterial.smooth ? false : true;\n          material.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;\n          createdMaterials.push(material);\n        } // Create mesh\n\n\n        var mesh;\n\n        if (createdMaterials.length > 1) {\n          for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            var sourceMaterial = materials[mi];\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n          }\n\n          if (isLine) {\n            mesh = new THREE.LineSegments(buffergeometry, createdMaterials);\n          } else if (isPoints) {\n            mesh = new THREE.Points(buffergeometry, createdMaterials);\n          } else {\n            mesh = new THREE.Mesh(buffergeometry, createdMaterials);\n          }\n        } else {\n          if (isLine) {\n            mesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n          } else if (isPoints) {\n            mesh = new THREE.Points(buffergeometry, createdMaterials[0]);\n          } else {\n            mesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);\n          }\n        }\n\n        mesh.name = object.name;\n        container.add(mesh);\n      }\n\n      console.timeEnd('OBJLoader');\n      return container;\n    }\n  };\n  return OBJLoader;\n}();\n\n//# sourceURL=webpack://COMGALLERY/./js/loader/OBJLoader.js?");

/***/ }),

/***/ "./js/loader/loader.js":
/*!*****************************!*\
  !*** ./js/loader/loader.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _FBXLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FBXLoader */ \"./js/loader/FBXLoader.js\");\n/* harmony import */ var _FBXLoader__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_FBXLoader__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _OBJLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OBJLoader */ \"./js/loader/OBJLoader.js\");\n/* harmony import */ var _OBJLoader__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_OBJLoader__WEBPACK_IMPORTED_MODULE_1__);\n/** Load FBX & OBJ */\n\n\n\nclass Loader {\n  constructor(path) {\n    this.path = `${APP_ROOT}/${path}/`;\n    this.materials = {};\n    this.images = {};\n    this.loaderFBX = new THREE.FBXLoader();\n    this.loaderOBJ = new THREE.OBJLoader();\n  }\n\n  loadFBX(file) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.loaderFBX.load(this.path + file + '.fbx', model => {\n          resolve(model);\n        });\n      } catch (error) {\n        console.log(error);\n        reject(error);\n      }\n    });\n  }\n\n  loadOBJ(file) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.loaderOBJ.load(this.path + file + '.obj', model => {\n          resolve(model);\n        });\n      } catch (error) {\n        console.log(error);\n        reject(error);\n      }\n    });\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Loader);\n\n//# sourceURL=webpack://COMGALLERY/./js/loader/loader.js?");

/***/ }),

/***/ "./js/maths/blend.js":
/*!***************************!*\
  !*** ./js/maths/blend.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Blend values */\nconst Blend = (a, b, t) => {\n  return a + (b - a) * t;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Blend);\n\n//# sourceURL=webpack://COMGALLERY/./js/maths/blend.js?");

/***/ }),

/***/ "./js/maths/clamp.js":
/*!***************************!*\
  !*** ./js/maths/clamp.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Clamp value */\nconst Clamp = (value, min, max) => {\n  return Math.min(max, Math.max(min, value));\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Clamp);\n\n//# sourceURL=webpack://COMGALLERY/./js/maths/clamp.js?");

/***/ }),

/***/ "./js/maths/min_angle_between.js":
/*!***************************************!*\
  !*** ./js/maths/min_angle_between.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Get min angle between angles */\nconst MinAngleBetween = function (a1, a2) {\n  return Math.atan2(Math.sin(a2 - a1), Math.cos(a2 - a1));\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MinAngleBetween);\n\n//# sourceURL=webpack://COMGALLERY/./js/maths/min_angle_between.js?");

/***/ }),

/***/ "./js/modules/artwork/artwork.js":
/*!***************************************!*\
  !*** ./js/modules/artwork/artwork.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _interaction_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction_node */ \"./js/modules/artwork/interaction_node.js\");\n/* harmony import */ var _video_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video_element */ \"./js/modules/artwork/video_element.js\");\n/** Artwork */\n\n\n\nclass Artwork {\n  constructor(root, index, data, isMobile) {\n    this.root = root;\n    this.ref = {\n      nav: root.ref.nav\n    };\n    this.id = 'artwork-' + index;\n    this.index = index;\n    this.data = data;\n    this.isMobile = isMobile; // props\n\n    this.active = false;\n    this.position = new THREE.Vector3();\n    this.direction = new THREE.Vector3();\n    this.nearRadius = 5;\n    this.thickness = 0.2;\n    this.artworkMenuActive = true;\n  }\n\n  init(scene, p, v) {\n    this.sceneReference = scene; // create meshes\n\n    const planeOffset = this.thickness / 2 + 0.01;\n    this.board = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), new THREE.MeshStandardMaterial({\n      color: 0x0,\n      roughness: 0.75,\n      metalness: 0\n    }));\n    this.plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1), new THREE.MeshStandardMaterial({\n      roughness: 1.0,\n      metalness: 0.5\n    })); // cache base\n\n    this.baseY = p.y; // set position, create node\n\n    p.x += (v.x != 0 ? 0 : 1) * this.data.horizontalOffset;\n    p.y += this.data.verticalOffset;\n    p.z += (v.z != 0 ? 0 : 1) * this.data.horizontalOffset;\n    this.plane.position.set(p.x + v.x * planeOffset, p.y, p.z + v.z * planeOffset);\n    this.position.set(p.x, p.y, p.z);\n    this.direction.set(v.x, v.y, v.z);\n    this.node = new _interaction_node__WEBPACK_IMPORTED_MODULE_0__[\"default\"](p, null, v, this); // calc view position\n\n    const offScale = this.isMobile ? 1.5 : 0.9;\n    this.viewPosition = new THREE.Vector3();\n    this.viewPosition.y = Math.min(7.8, this.baseY - 3);\n    this.viewPosition.x = p.x + v.x * Math.min((p.y - this.viewPosition.y) * offScale, 8);\n    this.viewPosition.z = p.z + v.z * Math.min((p.y - this.viewPosition.y) * offScale, 8); // spatially above ramp\n\n    if (p.x > 20 && p.z < -10) {\n      this.viewPosition.set(28, 4.4, -8);\n    } else if (p.x < -20 && p.z < -10) {\n      this.viewPosition.set(-28, 4.4, -8);\n    } // calc view rotation (pitch, yaw)\n\n\n    this.viewRotation = new THREE.Vector2();\n    this.viewRotation.y = Math.atan2(p.y - (this.viewPosition.y + this.root.ref.player.height) - 0.125, Math.hypot(p.x - this.viewPosition.x, p.z - this.viewPosition.z));\n    this.viewRotation.x = Math.atan2(p.x - this.viewPosition.x, p.z - this.viewPosition.z); // set default board scale\n\n    this.board.scale.x = v.x != 0 ? this.thickness : 1;\n    this.board.scale.z = v.z != 0 ? this.thickness : 1;\n    this.board.position.set(p.x, p.y, p.z); // get texture from image file/ or link to video\n\n    let texture;\n\n    if (this.data.videoFile !== '') {\n      const audioPosition = new THREE.Vector3();\n      audioPosition.copy(this.plane.position);\n      audioPosition.x += v.x / 2;\n      audioPosition.z += v.z / 2;\n      this.videoElement = new _video_element__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.sceneReference, this.data.videoFile, this.data.audioFile, audioPosition, this.root.ref.camera); // video texture\n\n      texture = new THREE.VideoTexture(this.videoElement.getElement()); // set size\n\n      const width = this.data.width;\n      const height = width * (1080 / 1920);\n      this.plane.scale.x = width;\n      this.plane.scale.y = height;\n      this.board.scale.x = v.x != 0 ? this.thickness : width;\n      this.board.scale.y = height;\n      this.board.scale.z = v.z != 0 ? this.thickness : width; // set node\n\n      this.node.setCorners();\n    } else {\n      texture = new THREE.TextureLoader().load(this.data.url, tex => {\n        // scale to image dimensions\n        const height = this.data.width * (tex.image.naturalHeight / tex.image.naturalWidth);\n        this.plane.scale.x = this.data.width;\n        this.plane.scale.y = height;\n        this.board.scale.x = v.x != 0 ? this.thickness : this.data.width;\n        this.board.scale.y = height;\n        this.board.scale.z = v.z != 0 ? this.thickness : this.data.width; // set node\n\n        this.node.setCorners();\n      });\n    } // set artwork texture\n\n\n    this.plane.material.map = texture; // required for NPOT textures\n\n    texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;\n    texture.minFilter = THREE.LinearFilter; // rotate image plane accordingly\n\n    if (v.z == 1) {// default\n    } else if (v.z == -1) {\n      this.plane.rotation.y = Math.PI;\n    } else if (v.x == 1) {\n      this.plane.rotation.y = Math.PI * 0.5;\n    } else if (v.x == -1) {\n      this.plane.rotation.y = Math.PI * 1.5;\n    } // add\n\n\n    scene.add(this.plane);\n    scene.add(this.board);\n  }\n\n  mouseOver(x, y, player) {\n    this.node.mouseOver(x, y, player);\n  }\n\n  click(x, y, player) {\n    this.node.mouseOver(x, y, player);\n\n    if (this.node.isClickable()) {\n      this.root.moveToArtwork(this); // close menu if not current artwork\n\n      if (!this.isArtworkMenuMine()) {\n        this.ref.nav.closeArtworkInfo();\n      } // open menu\n\n\n      if (this.artworkMenuActive && this.node.buttonActive && this.node.buttonHover) {\n        this.ref.nav.openArtworkInfo(this);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  disableArtworkMenu() {\n    this.artworkMenuActive = false;\n    this.node.disableInfoTag();\n  }\n\n  isArtworkMenuMine() {\n    const target = this.ref.nav.el.gallery.artworkInfoPopup;\n    const img = target.querySelector('img');\n\n    if (img) {\n      return target.dataset.id === this.id && img.src === this.data.url;\n    } else {\n      return target.dataset.id === this.id;\n    }\n  }\n\n  update(delta, player, camera, cameraDir, centre) {\n    this.node.update(delta, player, camera, cameraDir, centre);\n\n    if (this.videoElement) {\n      this.videoElement.update(player.position);\n    }\n  }\n\n  draw(ctx) {\n    return this.node.draw(ctx);\n  }\n\n  destroy() {\n    this.sceneReference.remove(this.plane);\n    this.sceneReference.remove(this.board);\n\n    if (this.videoElement) {\n      this.videoElement.destroy();\n    }\n  }\n\n  removeHover() {\n    this.node.hover = false;\n  }\n\n  forceHover() {\n    this.node.hover = true;\n  }\n\n  getFloorPosition() {\n    return this.floorPosition;\n  }\n\n  isClickable() {\n    return this.node.isClickable();\n  }\n\n  resize() {\n    this.node.resize();\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Artwork);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/artwork/artwork.js?");

/***/ }),

/***/ "./js/modules/artwork/interaction_node.js":
/*!************************************************!*\
  !*** ./js/modules/artwork/interaction_node.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Convert UI screenspace interaction to world space, prform actions. */\nclass InteractionNode {\n  /** Initialise node from parent data. */\n  constructor(position, rotation, clipping, root) {\n    this.onscreen = true;\n    this.position = position;\n    this.rotation = rotation;\n    this.clipping = clipping || null;\n    this.coords = new THREE.Vector2();\n    this.helper = new THREE.Vector3(); // artwork root\n\n    this.root = root; // props\n\n    this.active = true;\n    this.hover = false;\n    this.cornersOK = false;\n    this.clickable = false;\n    this.buttonActive = false;\n    this.buttonRadius = 50;\n    this.buttonPosition = new THREE.Vector2();\n    this.buttonPosition.isClamped = false;\n    this.buttonHover = false;\n    this.textColour = Math.abs(position.x) <= 16 && (position.z > 10 || position.z < 0) ? '#000' : \"#fff\";\n    this.radius = {\n      min: this.root.isMobile ? 10 : 9,\n      max: 32\n    };\n    this.corners = {\n      world: {\n        a: new THREE.Vector3(),\n        b: new THREE.Vector3(),\n        c: new THREE.Vector3(),\n        d: new THREE.Vector3()\n      },\n      screen: {\n        a: new THREE.Vector2(),\n        b: new THREE.Vector2(),\n        c: new THREE.Vector2(),\n        d: new THREE.Vector2()\n      }\n    };\n    this.distance = -1; // init\n\n    this.resize();\n  }\n  /** Set 3d artwork corner positions. */\n\n\n  setCorners() {\n    // A --- B\n    // |     |\n    // D --- C\n    const p = this.root.position;\n    const v = this.root.direction;\n    const s = this.root.board.scale;\n    const scale = 0.5;\n    const xo = v.x * this.root.thickness / 2;\n    const zo = v.z * this.root.thickness / 2;\n    this.corners.world.a.set(p.x - (v.x != 0 ? 0 : s.x * scale) + xo, p.y + s.y * scale, p.z - (v.z != 0 ? 0 : s.z * scale) + zo);\n    this.corners.world.b.set(p.x + (v.x != 0 ? 0 : s.x * scale) + xo, p.y + s.y * scale, p.z + (v.z != 0 ? 0 : s.z * scale) + zo);\n    this.corners.world.c.set(p.x + (v.x != 0 ? 0 : s.x * scale) + xo, p.y - s.y * scale, p.z + (v.z != 0 ? 0 : s.z * scale) + zo);\n    this.corners.world.d.set(p.x - (v.x != 0 ? 0 : s.x * scale) + xo, p.y - s.y * scale, p.z - (v.z != 0 ? 0 : s.z * scale) + zo);\n  }\n  /** Convert 3d point to screen space. */\n\n\n  pointToScreen(p, camera, centre, target) {\n    const point = p.clone();\n    point.project(camera);\n    target.x = (point.x + 1) * centre.x;\n    target.y = (-point.y + 1) * centre.y;\n  }\n  /** calculate 2D corner positions and check for distortion. */\n\n\n  updateCorners(camera, centre) {\n    this.pointToScreen(this.corners.world.a, camera, centre, this.corners.screen.a);\n    this.pointToScreen(this.corners.world.b, camera, centre, this.corners.screen.b);\n    this.pointToScreen(this.corners.world.c, camera, centre, this.corners.screen.c);\n    this.pointToScreen(this.corners.world.d, camera, centre, this.corners.screen.d); // check if corners are okay\n\n    this.cornersOK = this.corners.screen.a.y < this.corners.screen.c.y && this.corners.screen.b.y < this.corners.screen.d.y && Math.abs(this.corners.screen.a.x - this.corners.screen.b.x) < window.innerWidth && !(this.corners.screen.a.x < 0 && this.corners.screen.c.x < 0) && !(this.corners.screen.a.x > this.rect.width && this.corners.screen.c.x > this.rect.width); // calculate [info] button position\n\n    this.buttonPosition.x = Math.max(this.corners.screen.c.x, this.corners.screen.d.x);\n    this.buttonPosition.y = (this.buttonPosition.x == this.corners.screen.c.x ? this.corners.screen.c.y : this.corners.screen.d.y) + 18; // clamp to screen\n\n    this.buttonPosition.isClamped = (this.buttonPosition.x > this.rect.width || this.buttonPosition.y > this.rect.height) && this.rect.width > Math.min(this.corners.screen.a.x, this.corners.screen.b.x) && this.rect.width > Math.min(this.corners.screen.c.x, this.corners.screen.d.x);\n\n    if (this.buttonPosition.isClamped) {\n      this.buttonPosition.x = this.rect.width - 16;\n      this.buttonPosition.y = this.rect.height - 16;\n    }\n  }\n  /** Disable. */\n\n\n  disableInfoTag() {\n    this.infoTagDisabled = true;\n  }\n  /** Prevent clicking through walls using arbitrary quadrants. */\n\n\n  isCorrectQuadrant(p) {\n    return p.x <= -16 || p.x >= 16 || this.position.x >= 16 || this.position.x <= -16 || p.z >= 6 && this.position.z >= 6 || p.z <= 6 && this.position.z <= 6;\n  }\n  /** Check if clickable and activate UI items. */\n\n\n  mouseOver(x, y, player) {\n    if (this.active && this.onscreen && this.cornersOK && this.isCorrectQuadrant(player)) {\n      const minX = Math.min(this.corners.screen.a.x, this.corners.screen.b.x, this.corners.screen.c.x, this.corners.screen.d.x) - 10;\n      const maxX = Math.max(this.corners.screen.a.x, this.corners.screen.b.x, this.corners.screen.c.x, this.corners.screen.d.x) + 10;\n      const minY = Math.min(this.corners.screen.a.y, this.corners.screen.b.y) - 10;\n      const maxY = Math.max(this.corners.screen.c.y, this.corners.screen.d.y) + 10; // check artwork box & button hover\n\n      this.buttonHover = this.buttonActive && Math.hypot(this.buttonPosition.x - x, this.buttonPosition.y - y) < this.buttonRadius + 10;\n      this.hover = this.buttonHover || x >= minX && x <= maxX && y >= minY && y <= maxY; // check for hover in the space between the artwork and the clamped button\n\n      if (this.buttonPosition.isClamped && !this.hover) {\n        this.hover = this.buttonPosition.x > maxX && x >= maxX - 100 && y >= this.rect.height - 100;\n      }\n    } else {\n      this.hover = false;\n      this.buttonHover = false;\n    } // set clickable flag\n\n\n    this.setClickable();\n  }\n  /** Set clickable flag. */\n\n\n  setClickable() {\n    this.clickable = this.onscreen && this.active && this.hover && this.cornersOK;\n  }\n  /** Return mouse hover state. */\n\n\n  isClickable() {\n    return this.clickable;\n  }\n  /** Calculate screen space position. */\n\n\n  calculateNodePosition(camera, worldVec, centre) {\n    this.helper.copy(camera.position);\n    this.helper.sub(this.position);\n    this.helper.normalize();\n\n    if (this.helper.dot(worldVec) <= 0) {\n      this.onscreen = true;\n      this.helper.copy(this.position);\n      this.helper.project(camera);\n      this.coords.x = (this.helper.x + 1) * centre.x;\n      this.coords.y = (-this.helper.y + 1) * centre.y;\n    } else {\n      this.onscreen = false;\n    } // clip plane\n\n\n    if (this.clipping && this.onscreen) {\n      this.helper.copy(camera.position);\n      this.helper.sub(this.position);\n\n      if (this.helper.dot(this.clipping) < 0) {\n        this.onscreen = false;\n      }\n    }\n  }\n  /** Update node. */\n\n\n  update(delta, player, camera, worldVec, centre) {\n    this.calculateNodePosition(camera, worldVec, centre);\n    this.distance = player.position.distanceTo(this.position); // activate or deactivate\n\n    this.active = this.distance <= this.radius.max;\n\n    if (this.active) {\n      this.updateCorners(camera, centre);\n      this.buttonActive = this.distance <= this.radius.min;\n    } // set clickable flag\n\n\n    this.setClickable();\n  }\n  /** Set visible flag & draw node with supplied context (2d). */\n\n\n  draw(ctx) {\n    if (this.clickable) {\n      ctx.globalAlpha = 1;\n      ctx.beginPath();\n      ctx.moveTo(this.corners.screen.a.x, this.corners.screen.a.y);\n      ctx.lineTo(this.corners.screen.b.x, this.corners.screen.b.y);\n      ctx.lineTo(this.corners.screen.c.x, this.corners.screen.c.y);\n      ctx.lineTo(this.corners.screen.d.x, this.corners.screen.d.y);\n      ctx.closePath();\n      ctx.stroke();\n\n      if (this.buttonActive) {\n        ctx.fillStyle = this.textColour;\n        ctx.textAlign = 'right';\n        ctx.globalAlpha = this.buttonHover && !this.infoTagDisabled ? 0.6 : 1;\n\n        if (!this.infoTagDisabled) {\n          ctx.fillText('[INFO]', this.buttonPosition.x, this.buttonPosition.y);\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n  /** Get canvas bounding rect reference. */\n\n\n  resize() {\n    this.rect = document.querySelector('#canvas-target').getBoundingClientRect();\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (InteractionNode);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/artwork/interaction_node.js?");

/***/ }),

/***/ "./js/modules/artwork/video_element.js":
/*!*********************************************!*\
  !*** ./js/modules/artwork/video_element.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Video load & interact */\nclass VideoElement {\n  constructor(sceneRef, videoSrc, audioSrc, position, camera) {\n    this.sceneRef = sceneRef;\n    this.radius = 17;\n    this.refDistance = 2;\n    this.rolloff = 1.4;\n    this.active = true; // create video element\n\n    this.video = document.createElement('video');\n    this.video.src = videoSrc;\n    this.video.muted = \"muted\";\n    this.video.loop = true;\n    this.video.load(); // audio element\n\n    if (audioSrc !== '') {\n      this.object3D = new THREE.Object3D();\n      this.object3D.position.copy(position);\n      this.sceneRef.add(this.object3D);\n      this.cameraRef = camera;\n      this.audioSrc = audioSrc;\n      this.audioRequired = true;\n    } else {\n      this.audioRequired = false;\n    }\n  }\n\n  initAudio() {\n    // init audio after user interaction (required by some browsers)\n    if (!this.cameraRef.listener) {\n      this.cameraRef.addAudioListener();\n    } // create audio node\n\n\n    this.audio = new THREE.PositionalAudio(this.cameraRef.listener);\n    this.audioContext = this.audio.context;\n    this.audioLoader = new THREE.AudioLoader();\n    this.audioLoader.load(this.audioSrc, buffer => {\n      if (this.active) {\n        this.audio.setBuffer(buffer);\n        this.audio.setRefDistance(this.refDistance);\n        this.audio.setRolloffFactor(this.rolloff);\n        this.audio.setDistanceModel('exponential');\n        this.audio.loop = true;\n        this.audio.setVolume(0);\n        this.audio.play();\n        this.syncTracks();\n        this.fadeInRequired = true;\n      }\n    }); // add sound to mesh\n\n    this.object3D.add(this.audio); // flag\n\n    this.audioRequired = false;\n  }\n\n  fadeInAudio() {\n    if (this.active) {\n      const v = Math.min(1, this.audio.getVolume() + 0.01);\n\n      if (v == 1) {\n        this.fadeInRequired = false;\n      }\n\n      this.audio.setVolume(v);\n    }\n  }\n\n  pauseVideo() {\n    if (!this.video.paused) {\n      this.video.pause();\n    }\n  }\n\n  resumeVideo() {\n    if (this.video.paused) {\n      this.syncTracks();\n      this.video.play();\n    }\n  }\n\n  syncTracks() {\n    // sync video with audio\n    if (this.audioContext) {\n      const t = this.audioContext.currentTime;\n      this.video.currentTime = t > this.video.duration ? t % this.video.duration : t;\n    }\n  }\n\n  update(p) {\n    // defer audio init (browser requirement)\n    if (this.audioRequired) {\n      this.initAudio();\n    } // fade in\n\n\n    if (this.fadeInRequired) {\n      this.fadeInAudio();\n    } // play or pause video\n\n\n    if (this.object3D.position.distanceTo(p) > this.radius) {\n      this.pauseVideo();\n    } else {\n      this.resumeVideo();\n    }\n  }\n\n  destroy() {\n    this.active = false; // destroy\n\n    if (this.object3D) {\n      this.sceneRef.remove(this.object3D);\n\n      if (this.audio && this.audio.isPlaying) {\n        this.object3D.remove(this.audio);\n        this.audio.pause();\n      }\n    }\n\n    if (this.video) {\n      this.video.pause();\n    }\n  }\n\n  getElement() {\n    return this.video;\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VideoElement);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/artwork/video_element.js?");

/***/ }),

/***/ "./js/modules/camera.js":
/*!******************************!*\
  !*** ./js/modules/camera.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./js/modules/config.js\");\n/** Camera */\n\n\nclass Camera {\n  constructor(root) {\n    this.fov = 65;\n    this.aspectRatio = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderer.getWidth() / _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderer.getHeight();\n    this.offset = 0.1;\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspectRatio, 0.1, 2000000);\n    this.camera.up = new THREE.Vector3(0, 1, 0);\n    this.camera.rotation.order = 'YXZ';\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.player = root.modules.player;\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  addAudioListener() {\n    this.listener = new THREE.AudioListener();\n    this.camera.add(this.listener);\n  }\n\n  resize() {\n    this.aspectRatio = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderer.getWidth() / _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderer.getHeight();\n    this.camera.aspect = this.aspectRatio;\n    this.camera.updateProjectionMatrix();\n  }\n\n  update(delta) {\n    const offsetXZ = this.offset - this.offset * Math.abs(Math.sin(this.ref.player.rotation.y));\n    const offsetY = this.offset;\n    const y = this.ref.player.position.y + this.ref.player.height;\n    this.camera.position.set(this.ref.player.position.x, this.ref.player.position.y + this.ref.player.height, this.ref.player.position.z);\n    this.camera.rotation.y = this.ref.player.rotation.x + Math.PI;\n    this.camera.rotation.x = this.ref.player.rotation.y;\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Camera);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/camera.js?");

/***/ }),

/***/ "./js/modules/canvas_2d.js":
/*!*********************************!*\
  !*** ./js/modules/canvas_2d.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./js/modules/config.js\");\n/** Render 2D Overlays */\n\n\nclass Canvas2D {\n  constructor(root, domElement, canvasTarget) {\n    this.cvs = document.createElement('canvas');\n    this.ctx = this.cvs.getContext('2d');\n    document.querySelector('#canvas-target').appendChild(this.cvs);\n    this.resize(); // draw settings\n\n    this.prompt = {};\n    this.prompt.touchMove = {\n      alpha: {\n        current: 0,\n        min: 0,\n        max: 1\n      },\n      size: {\n        current: 22,\n        min: 22,\n        max: 24\n      }\n    };\n    this.prompt.click = {\n      alpha: {\n        current: 0,\n        min: 0,\n        max: 1\n      }\n    };\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.player = root.modules.player;\n    this.ref.renderer = root.modules.renderer; // bind events\n\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.cvs.width, this.cvs.height);\n    this.ctx.font = '16px Karla';\n    this.ctx.strokeStyle = '#fff';\n    this.ctx.fillStyle = '#fff';\n    this.ctx.lineWidth = 1.5;\n    this.ctx.lineCap = 'round';\n  }\n\n  resize() {\n    this.cvs.width = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderer.getWidth();\n    this.cvs.height = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderer.getHeight();\n  }\n\n  promptClick(text, active, x, y) {\n    this.prompt.click.alpha.current += active ? (this.prompt.click.alpha.max - this.prompt.click.alpha.current) * 0.2 : (this.prompt.click.alpha.min - this.prompt.click.alpha.current) * 0.2;\n\n    if (this.prompt.click.alpha.current > 0) {\n      this.ctx.globalAlpha = this.prompt.click.alpha.current;\n      this.ctx.fillText(text, x + 12, y + 12);\n    }\n  }\n\n  promptTouchMove(active) {\n    // animate in/out prompt\n    if (active) {\n      this.prompt.touchMove.alpha.current += (this.prompt.touchMove.alpha.max - this.prompt.touchMove.alpha.current) * 0.2;\n      this.prompt.touchMove.size.current += (this.prompt.touchMove.size.max - this.prompt.touchMove.size.current) * 0.2;\n    } else {\n      this.prompt.touchMove.alpha.current += (this.prompt.touchMove.alpha.min - this.prompt.touchMove.alpha.current) * 0.2;\n      this.prompt.touchMove.size.current += (this.prompt.touchMove.size.min - this.prompt.touchMove.size.current) * 0.2;\n    } // draw touchmove prompt\n\n\n    if (this.prompt.touchMove.alpha.current > 0) {\n      const cx = this.cvs.width / 2;\n      const cy = this.cvs.height / 2;\n      const s1 = this.prompt.touchMove.size.current;\n      const s2 = s1 * 2;\n      this.ctx.globalAlpha = this.prompt.touchMove.alpha.current;\n      this.ctx.beginPath(); //this.ctx.arc(cx, cy, s1 / 2, 0, Math.PI * 2, false);\n\n      this.ctx.moveTo(cx - s2, cy - s2 + s1);\n      this.ctx.lineTo(cx - s2, cy - s2);\n      this.ctx.lineTo(cx - s2 + s1, cy - s2);\n      this.ctx.moveTo(cx + s2, cy + s2 - s1);\n      this.ctx.lineTo(cx + s2, cy + s2);\n      this.ctx.lineTo(cx + s2 - s1, cy + s2);\n      this.ctx.moveTo(cx - s2, cy + s2 - s1);\n      this.ctx.lineTo(cx - s2, cy + s2);\n      this.ctx.lineTo(cx - s2 + s1, cy + s2);\n      this.ctx.moveTo(cx + s2, cy - s2 + s1);\n      this.ctx.lineTo(cx + s2, cy - s2);\n      this.ctx.lineTo(cx + s2 - s1, cy - s2);\n      this.ctx.stroke();\n    }\n  }\n\n  promptGodMode() {\n    this.ctx.globalAlpha = 1;\n    this.ctx.fillText('You can fly', 20, this.cvs.height - 40);\n    const x = Math.round(this.ref.player.position.x * 10) / 10;\n    const y = Math.round(this.ref.player.position.y * 10) / 10;\n    const z = Math.round(this.ref.player.position.z * 10) / 10;\n    const rx = Math.round(this.ref.player.rotation.x * 100) / 100;\n    this.ctx.fillText(`${x}, ${y}, ${z}, ${rx}`, 20, this.cvs.height - 20);\n  }\n\n  drawDevOverlay() {//\n  }\n\n  getContext() {\n    return this.ctx;\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Canvas2D);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/canvas_2d.js?");

/***/ }),

/***/ "./js/modules/config.js":
/*!******************************!*\
  !*** ./js/modules/config.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Config */\nconst space = 8;\nconst Config = {\n  renderer: {\n    getWidth: () => {\n      return Math.max(100, window.innerWidth - space * 14);\n    },\n    getHeight: () => {\n      return Math.max(100, window.innerHeight - space * 16);\n    }\n  },\n  floorPlan: {\n    artworkPositions: [// 32 in total\n    // brick wall (8)\n    {\n      x: -24,\n      y: 4,\n      z: 23,\n      nx: 0,\n      nz: -1\n    }, {\n      x: -10.5,\n      y: 3.5,\n      z: 23,\n      nx: 0,\n      nz: -1\n    }, {\n      x: -8,\n      y: 3.5,\n      z: 23,\n      nx: 0,\n      nz: -1\n    }, {\n      x: -5.5,\n      y: 3.5,\n      z: 23,\n      nx: 0,\n      nz: -1\n    }, {\n      x: 5.5,\n      y: 3.5,\n      z: 23,\n      nx: 0,\n      nz: -1\n    }, {\n      x: 8,\n      y: 3.5,\n      z: 23,\n      nx: 0,\n      nz: -1\n    }, {\n      x: 10.5,\n      y: 3.5,\n      z: 23,\n      nx: 0,\n      nz: -1\n    }, {\n      x: 24,\n      y: 4,\n      z: 23,\n      nx: 0,\n      nz: -1\n    }, // central block A (6)\n    {\n      x: -12,\n      y: 3.5,\n      z: 8,\n      nx: 0,\n      nz: 1\n    }, {\n      x: -8,\n      y: 3.5,\n      z: 8,\n      nx: 0,\n      nz: 1\n    }, {\n      x: -4,\n      y: 3.5,\n      z: 8,\n      nx: 0,\n      nz: 1\n    }, {\n      x: 4,\n      y: 3.5,\n      z: 8,\n      nx: 0,\n      nz: 1\n    }, {\n      x: 8,\n      y: 3.5,\n      z: 8,\n      nx: 0,\n      nz: 1\n    }, {\n      x: 12,\n      y: 3.5,\n      z: 8,\n      nx: 0,\n      nz: 1\n    }, // end walls (6)\n    {\n      x: -31,\n      y: 4,\n      z: 14,\n      nx: 1,\n      nz: 0\n    }, {\n      x: -29.5,\n      y: 4,\n      z: 6,\n      nx: 1,\n      nz: 0\n    }, {\n      x: -31,\n      y: 4,\n      z: -2,\n      nx: 1,\n      nz: 0\n    }, {\n      x: 32,\n      y: 4,\n      z: 14,\n      nx: -1,\n      nz: 0\n    }, {\n      x: 30,\n      y: 4,\n      z: 6,\n      nx: -1,\n      nz: 0\n    }, {\n      x: 32,\n      y: 4,\n      z: -2,\n      nx: -1,\n      nz: 0\n    }, // central block B (6)\n    {\n      x: -12,\n      y: 3.5,\n      z: 4,\n      nx: 0,\n      nz: -1\n    }, {\n      x: -8,\n      y: 3.5,\n      z: 4,\n      nx: 0,\n      nz: -1\n    }, {\n      x: -4,\n      y: 3.5,\n      z: 4,\n      nx: 0,\n      nz: -1\n    }, {\n      x: 4,\n      y: 3.5,\n      z: 4,\n      nx: 0,\n      nz: -1\n    }, {\n      x: 8,\n      y: 3.5,\n      z: 4,\n      nx: 0,\n      nz: -1\n    }, {\n      x: 12,\n      y: 3.5,\n      z: 4,\n      nx: 0,\n      nz: -1\n    }, // white wall downstairs (2)\n    {\n      x: -8,\n      y: 3.5,\n      z: -11.5,\n      nx: 0,\n      nz: 1\n    }, {\n      x: 8,\n      y: 3.5,\n      z: -11.5,\n      nx: 0,\n      nz: 1\n    }, // upstairs (4)\n    {\n      x: -24,\n      y: 11,\n      z: -11,\n      nx: 0,\n      nz: 1\n    }, {\n      x: -8,\n      y: 11,\n      z: -11.5,\n      nx: 0,\n      nz: 1\n    }, {\n      x: 8,\n      y: 11,\n      z: -11.5,\n      nx: 0,\n      nz: 1\n    }, {\n      x: 24,\n      y: 11,\n      z: -11,\n      nx: 0,\n      nz: 1\n    }]\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Config);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/config.js?");

/***/ }),

/***/ "./js/modules/custom_exhibition.js":
/*!*****************************************!*\
  !*** ./js/modules/custom_exhibition.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _loader_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader/loader */ \"./js/loader/loader.js\");\n/* harmony import */ var _maths_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maths/clamp */ \"./js/maths/clamp.js\");\n/** Custom exhibition handler */\n\n\n\nclass CustomExhibition {\n  constructor() {\n    this.assets = [];\n    this.loader = new _loader_loader__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('assets');\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.scene = root.modules.scene;\n    this.ref.materials = root.modules.materials;\n    this.ref.player = root.modules.player;\n  }\n\n  load(data) {\n    // reset update callback\n    this.updateCallback = null; // remove any current exhibition assets from scene\n\n    this.assets.forEach(asset => {\n      if (asset.isMesh) {\n        this.ref.scene.scene.remove(asset);\n      } else if (asset.object) {\n        this.ref.scene.scene.remove(asset.object);\n\n        if (asset.sparks) {\n          asset.sparks.forEach(spark => {\n            this.ref.scene.scene.remove(spark.object);\n          });\n        }\n      }\n    });\n    this.assets = []; // new installation\n\n    switch (data.customValue) {\n      case 'JACK_DE_LACY':\n        this.loadJack();\n        break;\n\n      case 'TIYAN':\n        this.loadTiyan();\n        break;\n\n      case 'BRENTON':\n        this.loadBrenton();\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  loadJack() {\n    // jack's assets\n    this.assets = [{\n      src: 'jack_de_lacy/sculpture_1',\n      scale: 0.6,\n      rot: Math.PI / 32,\n      orientZ: Math.PI / 4\n    }, {\n      src: 'jack_de_lacy/sculpture_2',\n      scale: 0.5,\n      rot: -Math.PI / 32,\n      orientZ: 0\n    }, {\n      src: 'jack_de_lacy/sculpture_3',\n      scale: 0.5,\n      rot: Math.PI / 32,\n      orientZ: 0\n    }]; // callback\n\n    this.updateCallback = delta => {\n      this.assets.forEach(asset => {\n        if (asset.object) {\n          asset.object.rotation.y += asset.rot * delta;\n        }\n      });\n    }; // load\n\n\n    for (var i = 0; i < this.assets.length; ++i) {\n      const index = i; // load object & add references\n\n      this.loader.loadFBX(this.assets[index].src).then(obj => {\n        obj.children.forEach(child => {\n          this.ref.materials.conformMaterial(child.material);\n          child.material = this.ref.materials.getCustomMaterial(child.material);\n          child.material.envMapIntensity = 0.25;\n\n          if (index == 2) {\n            child.material.side = THREE.DoubleSide;\n          }\n        }); // initial position\n\n        obj.scale.multiplyScalar(this.assets[index].scale);\n        obj.rotation.z = this.assets[index].orientZ;\n        obj.position.set(-12 + index * 12, 14, 6); // add to scene & asset reference list\n\n        this.ref.scene.scene.add(obj);\n        this.assets[index].object = obj;\n      }, err => {\n        console.log(err);\n      });\n    }\n  }\n\n  loadTiyan() {\n    // load models\n    this.loader.loadFBX('tiyan/separators').then(obj => {\n      this.ref.materials.conformGroup(obj);\n      this.ref.scene.scene.add(obj);\n      this.assets.push({\n        object: obj\n      });\n    }); // add separator collisions\n\n    const mesh1 = new THREE.Mesh(new THREE.BoxBufferGeometry(14, 4, 1.5), new THREE.MeshStandardMaterial({}));\n    const mesh2 = new THREE.Mesh(new THREE.BoxBufferGeometry(1.5, 4, 16), new THREE.MeshStandardMaterial({}));\n    mesh1.position.set(-23, 1, 6);\n    mesh2.position.set(17.25, 1, 15.5);\n    this.ref.scene.colliderSystem.add(mesh1);\n    this.ref.scene.colliderSystem.add(mesh2);\n  }\n\n  loadBrenton() {\n    this.assets = ['brenton/crash7/crash_7', 'brenton/crash8/crash_8', 'brenton/crash9/crash_9', 'brenton/crash11/crash_11', 'brenton/crash12/crash_12', 'brenton/crash13/crash_13', 'brenton/new_crashform/new_crashform'].map(str => {\n      return {\n        src: str\n      };\n    });\n\n    const setInstallation = child => {\n      // set material\n      const mat = new THREE.MeshPhysicalMaterial({});\n      mat.map = child.material.map ? child.material.map : null;\n\n      if (!mat.map) {\n        mat.color = child.material.color;\n        mat.emissive = child.material.color;\n        mat.emissiveIntensity = 0.1;\n      } //mat.envMap = child.material.envMap ? child.material.envMap : null;\n\n\n      mat.envMap = this.ref.materials.envMap;\n      mat.envMapIntensity = 0.5;\n      mat.normalMap = child.material.normalMap ? child.material.normalMap : null;\n      mat.metalness = child.material.metalness ? child.material.metalness : 0.75;\n      mat.roughness = child.material.roughness ? child.material.roughness : 0.5;\n      mat.side = THREE.DoubleSide;\n\n      if (child.material.transparent) {\n        mat.transparent = true;\n        mat.opacity = child.material.opacity;\n      } // NPOT\n\n\n      if (mat.map) {\n        mat.map.wrapS = mat.map.wrapT = THREE.ClampToEdgeWrapping;\n        mat.map.minFilter = THREE.LinearFilter;\n      }\n\n      if (mat.normalMap) {\n        mat.normalMap.wrapS = mat.normalMap.wrapT = THREE.ClampToEdgeWrapping;\n        mat.normalMap.minFilter = THREE.LinearFilter;\n      } // set new material\n\n\n      child.material = mat; // limit position\n\n      const rad = 0.25;\n      child.customPos = {};\n      child.customPos.x = {\n        max: child.position.x + rad,\n        min: child.position.x - rad\n      };\n      child.customPos.y = {\n        max: child.position.y + rad,\n        min: child.position.y - rad\n      };\n      child.customPos.z = {\n        max: child.position.z + rad,\n        min: child.position.z - rad\n      }; // animation type\n\n      const box = new THREE.Box3();\n      box.setFromObject(child);\n      const size = new THREE.Vector3();\n      box.getSize(size);\n      const sizeMax = 4;\n      const oversize = size.x > sizeMax || size.y > sizeMax || size.z > sizeMax;\n      child.animType = Math.random() > 0.3 || oversize ? 'jitter' : 'rotate';\n      child.rotationAxis = Math.random() > 0.5 ? 'y' : 'x';\n\n      if (child.name && child.name.indexOf('spin') != -1) {\n        child.animType = 'rotate';\n        child.rotationAxis = 'y';\n      }\n    };\n\n    this.assets.forEach(el => {\n      this.loader.loadFBX(el.src).then(obj => {\n        // add to scene and asset reference\n        this.ref.materials.conformGroup(obj);\n        this.ref.scene.scene.add(obj); // set car containers\n\n        el.object = obj;\n        el.sparks = [];\n        el.children = [];\n        el.smokeMat = new THREE.MeshPhongMaterial({\n          transparent: true,\n          side: THREE.DoubleSide,\n          opacity: 0.25\n        });\n        const tex = this.ref.materials.getTexture('brenton/smoke.png');\n        el.smokeMat.map = tex; // particle flag\n\n        if (el.src.indexOf('12') != -1) {\n          el.isLong = true;\n          el.radius = 40;\n        } // set children, find centre\n\n\n        let n = 0;\n        let p = new THREE.Vector3();\n        obj.children.forEach(child => {\n          if (child.type == 'Mesh') {\n            setInstallation(child);\n            el.children.push(child);\n            p.add(child.position);\n            n += 1;\n          } else if (child.type == 'Group') {\n            child.children.forEach(child => {\n              if (child.type == 'Mesh') {\n                setInstallation(child);\n                el.children.push(child);\n              }\n            });\n          }\n        }); // set centre\n\n        if (n != 0) {\n          p.divideScalar(n);\n        }\n\n        el.position = p;\n      });\n    });\n\n    this.updateCallback = delta => {\n      for (let i = 0, lim = this.assets.length; i < lim; ++i) {\n        if (this.assets[i].children) {\n          const target = this.assets[i];\n          const threshold = 3;\n          const radius = target.radius ? target.radius : 25;\n          const dist = this.ref.player.position.distanceTo(target.position);\n          const f = dist < threshold ? 1 : Math.max(0, 1 - (dist - threshold) / (radius - threshold));\n          const amt = 0.0125; // animate car parts\n\n          target.children.forEach(child => {\n            if (child.animType == 'jitter') {\n              child.position.x = Object(_maths_clamp__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(child.position.x + f * (Math.random() * 2 - 1) * amt, child.customPos.x.min, child.customPos.x.max);\n              child.position.y = Object(_maths_clamp__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(child.position.y + f * (Math.random() * 2 - 1) * amt, child.customPos.y.min, child.customPos.y.max);\n              child.position.z = Object(_maths_clamp__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(child.position.z + f * (Math.random() * 2 - 1) * amt, child.customPos.z.min, child.customPos.z.max);\n            } else if (child.animType == 'rotate') {\n              child.rotation[child.rotationAxis] += (Math.random() * 2 - 1) * amt * f;\n            }\n          }); // create particles\n\n          if (target.sparks.length < 25 && Math.random() < f * 2) {\n            const spark = {};\n\n            if (Math.random() > 0.45) {\n              // SPARK\n              spark.object = new THREE.Mesh(new THREE.BoxBufferGeometry(0.02, 0.02, 0.04 + Math.random() * 0.5), new THREE.MeshBasicMaterial({\n                color: 0xffffff\n              }));\n              spark.object.position.copy(target.position);\n              spark.object.position.x += target.isLong ? Math.random() * 20 - 10 : Math.random() * 4 - 2;\n              spark.object.position.y += Math.random() * 3 - 1.5;\n              spark.object.position.z += Math.random() * 4 - 2;\n              spark.vec = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n              spark.vec.normalize();\n              spark.vec.multiplyScalar(5 + Math.random() * 15); // align spark\n\n              var p = new THREE.Vector3();\n              p.addVectors(spark.object.position, spark.vec);\n              spark.object.lookAt(p); // set age\n\n              spark.age = 0;\n              spark.maxAge = 0.125 + Math.random() * 0.25;\n            } else {\n              // SMOKE\n              spark.object = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), target.smokeMat);\n              spark.object.position.copy(target.position);\n              spark.object.position.x += target.isLong ? Math.random() * 6 - 3 : Math.random() * 1 - 0.5;\n              spark.object.position.y += 2 + (Math.random() * 1 - 0.5);\n              spark.object.position.z += Math.random() * 1 - 0.5;\n              spark.vec = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n              spark.vec.normalize();\n              spark.vec.multiplyScalar(2 + Math.random() * 4);\n              spark.object.rotation.set(Math.random(), Math.random(), Math.random()); // set age\n\n              spark.age = 0;\n              spark.maxAge = 0.25 + Math.random() * 0.5;\n            } // add to scene, animation array, asset reference\n\n\n            this.ref.scene.scene.add(spark.object);\n            target.sparks.push(spark);\n          } // animate particles\n\n\n          for (let j = target.sparks.length - 1, jlim = -1; j > jlim; j--) {\n            const spark = target.sparks[j];\n            spark.object.position.x += spark.vec.x * delta;\n            spark.object.position.y += spark.vec.y * delta;\n            spark.object.position.z += spark.vec.z * delta;\n            spark.age += delta;\n\n            if (spark.age > spark.maxAge) {\n              this.ref.scene.scene.remove(spark.object);\n              target.sparks.splice(j, 1);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  update(delta) {\n    if (this.updateCallback) {\n      this.updateCallback(delta);\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CustomExhibition);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/custom_exhibition.js?");

/***/ }),

/***/ "./js/modules/floor_plan.js":
/*!**********************************!*\
  !*** ./js/modules/floor_plan.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./js/modules/config.js\");\n/* harmony import */ var _artwork_artwork__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./artwork/artwork */ \"./js/modules/artwork/artwork.js\");\n/* harmony import */ var _utils_is_mobile_device__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/is_mobile_device */ \"./js/utils/is_mobile_device.js\");\n/** Load, place and manage artworks. */\n\n\n\n\nclass FloorPlan {\n  constructor() {\n    this.isMobile = Object(_utils_is_mobile_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n    this.artworks = [];\n    this.artworkActiveRadius = 10;\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.player = root.modules.player;\n    this.ref.camera = root.modules.camera;\n    this.ref.scene = root.modules.scene.scene;\n    this.ref.surface = root.modules.surface;\n    this.ref.cameraDirection = new THREE.Vector3();\n    this.ref.nav = root.ref.nav;\n  }\n\n  load(data) {\n    this.unload();\n\n    if (data.images) {\n      // create new artworks\n      const slots = [];\n      data.images.forEach(imageData => {\n        const artwork = new _artwork_artwork__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, this.artworks.length, imageData, this.isMobile);\n        const slot = artwork.data.location - 1; // placement\n\n        if (slot < _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].floorPlan.artworkPositions.length) {\n          const pos = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].floorPlan.artworkPositions[slot]; // check for duplicate location\n\n          if (slots.indexOf(slot) == -1) {\n            slots.push(slot);\n          } else {\n            console.log('Warning: Duplicate slot reference:', slot);\n          } // load artwork\n\n\n          artwork.init(this.ref.scene, new THREE.Vector3(pos.x, pos.y, pos.z), new THREE.Vector3(pos.nx, 0, pos.nz));\n          this.artworks.push(artwork);\n        } else {\n          console.log('Warning: No valid slot:', slot);\n        }\n      });\n    }\n  }\n\n  unload() {\n    // remove all artworks\n    this.artworks.forEach(artwork => {\n      try {\n        artwork.destroy();\n      } catch (err) {\n        console.log(err);\n      }\n    });\n    this.artworks = [];\n  }\n\n  mouseOver(x, y) {\n    var isHovered = [];\n\n    for (var i = 0, len = this.artworks.length; i < len; ++i) {\n      this.artworks[i].mouseOver(x, y, this.ref.player.position);\n\n      if (this.artworks[i].isClickable()) {\n        isHovered.push(this.artworks[i]);\n      }\n    }\n\n    if (isHovered.length > 1) {\n      var dmax = 100;\n      var res = isHovered[0];\n\n      for (var i = 0; i < isHovered.length; ++i) {\n        isHovered[i].removeHover();\n        const d = this.ref.player.position.distanceTo(isHovered[i].position);\n\n        if (d < dmax) {\n          dmax = d;\n          res = isHovered[i];\n        }\n      }\n\n      res.forceHover();\n    }\n\n    if (isHovered.length) {\n      this.ref.surface.el.canvasTarget.classList.add('clickable');\n    } else {\n      this.ref.surface.el.canvasTarget.classList.remove('clickable');\n    }\n  }\n\n  click(x, y) {\n    for (var i = 0, len = this.artworks.length; i < len; ++i) {\n      if (this.artworks[i].click(x, y, this.ref.player.position)) {\n        break;\n      }\n    }\n  }\n\n  moveToArtwork(artwork) {\n    this.ref.player.moveToArtwork(artwork);\n  }\n\n  update(delta) {\n    this.ref.camera.camera.getWorldDirection(this.ref.cameraDirection);\n\n    for (var i = 0, lim = this.artworks.length; i < lim; ++i) {\n      this.artworks[i].update(delta, this.ref.player, this.ref.camera.camera, this.ref.cameraDirection, this.ref.surface.centre);\n    }\n  }\n\n  draw(ctx) {\n    for (var i = 0, len = this.artworks.length; i < len; ++i) {\n      if (this.artworks[i].draw(ctx)) {\n        break;\n      }\n    }\n  }\n\n  resize() {\n    this.artworks.forEach(e => {\n      e.resize();\n    });\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FloorPlan);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/floor_plan.js?");

/***/ }),

/***/ "./js/modules/gallery.js":
/*!*******************************!*\
  !*** ./js/modules/gallery.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./camera */ \"./js/modules/camera.js\");\n/* harmony import */ var _canvas_2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas_2d */ \"./js/modules/canvas_2d.js\");\n/* harmony import */ var _floor_plan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./floor_plan */ \"./js/modules/floor_plan.js\");\n/* harmony import */ var _lighting__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lighting */ \"./js/modules/lighting.js\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map */ \"./js/modules/map.js\");\n/* harmony import */ var _materials__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./materials */ \"./js/modules/materials.js\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./player */ \"./js/modules/player.js\");\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderer */ \"./js/modules/renderer.js\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./scene */ \"./js/modules/scene.js\");\n/* harmony import */ var _surface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./surface */ \"./js/modules/surface.js\");\n/** Gallery entry point */\n\n\n\n\n\n\n\n\n\n\n\nclass Gallery {\n  constructor() {\n    this.modules = {\n      renderer: new _renderer__WEBPACK_IMPORTED_MODULE_7__[\"default\"](),\n      scene: new _scene__WEBPACK_IMPORTED_MODULE_8__[\"default\"](),\n      player: new _player__WEBPACK_IMPORTED_MODULE_6__[\"default\"](),\n      camera: new _camera__WEBPACK_IMPORTED_MODULE_0__[\"default\"](),\n      floorPlan: new _floor_plan__WEBPACK_IMPORTED_MODULE_2__[\"default\"](),\n      lighting: new _lighting__WEBPACK_IMPORTED_MODULE_3__[\"default\"](),\n      map: new _map__WEBPACK_IMPORTED_MODULE_4__[\"default\"](),\n      materials: new _materials__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n      surface: new _surface__WEBPACK_IMPORTED_MODULE_9__[\"default\"](),\n      canvas2d: new _canvas_2d__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()\n    };\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.nav = root.modules.nav; // bind modules\n\n    Object.keys(this.modules).forEach(key => {\n      this.modules[key].bind(this);\n    }); // start main loop\n\n    this.loop();\n  }\n\n  load(data) {\n    // reset player position & scene\n    this.modules.player.reset();\n    this.modules.scene.reset(); // add artist name\n\n    document.querySelector('#open-gallery-artist').innerText = data.artistName || '';\n    document.querySelector('#open-gallery-prompt').classList.add('loading'); // load map\n\n    this.modules.map.load(data).then(() => {\n      this.modules.floorPlan.load(data);\n      this.modules.lighting.load(data); // reset \"open\" prompt\n\n      const prompt = document.querySelector('#open-gallery-prompt');\n      prompt.classList.remove('loading');\n      prompt.classList.add('prompt-action');\n    });\n  }\n\n  start() {\n    this.timer = {\n      previous: performance.now()\n    };\n    this.active = true;\n  }\n\n  pause() {\n    this.active = false;\n  }\n\n  loop() {\n    requestAnimationFrame(() => {\n      this.loop();\n    });\n\n    if (this.active) {\n      const now = performance.now();\n      const delta = Math.min(0.1, (now - this.timer.previous) / 1000);\n      this.timer.previous = now; // update modules\n\n      Object.keys(this.modules).forEach(key => {\n        if (this.modules[key].update) {\n          this.modules[key].update(delta);\n        }\n      }); // render\n\n      this.modules.renderer.render(delta);\n      this.modules.surface.render();\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Gallery);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/gallery.js?");

/***/ }),

/***/ "./js/modules/lighting.js":
/*!********************************!*\
  !*** ./js/modules/lighting.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Lighting handler */\nclass Lighting {\n  constructor() {\n    // lights\n    this.lights = {\n      point: {},\n      ambient: {},\n      directional: {},\n      hemisphere: {},\n      spot: {}\n    };\n    this.lights.point.a = new THREE.PointLight(0xffffff, 1, 24, 2);\n    this.lights.point.b = new THREE.PointLight(0xffffff, 1, 32, 2);\n    this.lights.point.c = new THREE.PointLight(0xffffff, 1, 20, 2);\n    this.lights.ambient.a = new THREE.AmbientLight(0xffffff, 0.3);\n    this.lights.directional.a = new THREE.DirectionalLight(0xffffff, 0.5);\n    this.lights.hemisphere.a = new THREE.HemisphereLight(0x0, 0x0000ff, 0.25);\n    this.lights.spot.a = new THREE.SpotLight(0xffffff, 1, 32, Math.PI / 3, 0.25);\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.scene = root.modules.scene.scene;\n  }\n\n  load(data) {\n    // default positions\n    this.lights.point.a.position.set(-8, 10, 14);\n    this.lights.point.b.position.set(0, 10, -4);\n    this.lights.point.c.position.set(26, 10, 6);\n    this.lights.directional.a.position.set(-1, 1.5, -1);\n    this.lights.spot.a.position.set(0, 10, 14);\n    this.lights.spot.a.target.position.set(-4, 0, 6); // default settings\n\n    this.lights.point.a.distance = 24;\n    this.lights.hemisphere.a.intensity = 0.25;\n    this.lights.ambient.a.intensity = 0.3;\n    this.lights.spot.a.intensity = 1;\n    this.lights.spot.a.distance = 32;\n    this.lights.spot.a.angle = Math.PI / 3;\n    this.lights.spot.a.penumbra = 0.25; // add lights\n\n    Object.keys(this.lights).forEach(type => {\n      Object.keys(this.lights[type]).forEach(key => {\n        const light = this.lights[type][key];\n        this.ref.scene.add(light);\n\n        if (light.isSpotLight) {\n          this.ref.scene.add(light.target);\n        }\n      });\n    }); // remove fog\n\n    this.ref.scene.fog = new THREE.FogExp2(0x000000, 0); // custom exhibition lighting\n\n    switch (data.customValue) {\n      case 'TIYAN':\n        // remove lights outside temp exhibition region\n        this.ref.scene.remove(this.lights.directional.a);\n        this.ref.scene.remove(this.lights.point.b); // reposition & colour lights\n\n        this.lights.ambient.a.intensity = 0.1;\n        this.lights.point.b.position.set(6, 10, 14);\n        this.lights.point.a.position.set(2, 9, 18);\n        this.lights.point.a.distance = 26;\n        this.lights.point.c.position.set(-22, 8, 18);\n        this.lights.hemisphere.a.intensity = 0.01;\n        break;\n\n      case 'BRENTON':\n        // spotlight for car\n        this.lights.spot.a.position.set(-26, 10, 1);\n        this.lights.spot.a.target.position.set(-22, 0, 1);\n        this.lights.spot.a.angle = Math.PI / 6;\n        this.lights.spot.a.penumbra = 0.1;\n        break;\n\n      case 'JACK_DE_LACY':\n      default:\n        this.ref.scene.remove(this.lights.spot.a);\n        this.ref.scene.remove(this.lights.spot.a.target);\n        break;\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Lighting);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/lighting.js?");

/***/ }),

/***/ "./js/modules/map.js":
/*!***************************!*\
  !*** ./js/modules/map.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _loader_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader/loader */ \"./js/loader/loader.js\");\n/* harmony import */ var _maths_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maths/clamp */ \"./js/maths/clamp.js\");\n/* harmony import */ var _custom_exhibition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./custom_exhibition */ \"./js/modules/custom_exhibition.js\");\n/** Load & update models */\n\n\n\n\nclass Map {\n  constructor() {\n    this.assets = {};\n    this.loader = new _loader_loader__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('assets');\n    this.customExhibition = new _custom_exhibition__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.root = root;\n    this.ref.scene = root.modules.scene;\n    this.ref.player = root.modules.player;\n    this.ref.materials = root.modules.materials; // bind custom exhibition handler\n\n    this.customExhibition.bind(root);\n  }\n\n  load(data) {\n    return new Promise((resolve, reject) => {\n      this.customExhibition.load(data);\n      this.loadDefaultExhibition(() => {\n        resolve();\n      });\n    });\n  }\n\n  loadDefaultExhibition(callback) {\n    // load persistent assets\n    let requiredAssets = 2;\n\n    const checkLoaded = () => {\n      requiredAssets -= 1;\n\n      if (requiredAssets === 0) {\n        callback();\n      }\n    }; // add collision map async\n\n\n    if (!this.assets.defaultCollisionMap) {\n      this.loader.loadOBJ('collision').then(map => {\n        this.assets.defaultCollisionMap = map;\n        this.addCollisionMap(this.assets.defaultCollisionMap);\n        checkLoaded();\n      }, err => {\n        console.log(err);\n      });\n    } else {\n      checkLoaded();\n      this.addCollisionMap(this.assets.defaultCollisionMap);\n    } // add map async\n\n\n    if (!this.assets.map) {\n      this.loader.loadFBX('map').then(map => {\n        this.ref.scene.scene.add(map);\n        this.ref.materials.conformGroup(map);\n        checkLoaded();\n      }, err => {\n        console.log(err);\n      });\n    } else {\n      checkLoaded();\n    } // add floor collision map\n\n\n    if (!this.assets.floor) {\n      this.assets.floor = new THREE.Mesh(new THREE.BoxBufferGeometry(100, 1, 100), new THREE.MeshPhongMaterial({}));\n      this.assets.floor.position.y = -0.25;\n    }\n\n    this.addCollisionMap(this.assets.floor); // load props\n\n    if (!this.assets.props) {\n      this.loader.loadFBX('props').then(map => {\n        this.assets.props = map;\n        this.ref.scene.scene.add(map);\n        this.ref.materials.conformGroup(map);\n      });\n    } // ceiling lights\n\n\n    if (!this.assets.ceilingLights) {\n      const size = 0.1;\n      const rodSize = 4;\n\n      for (var x = -16; x <= 16; x += 8) {\n        const y = 19;\n        const mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(size, size, rodSize), this.ref.materials.mat.neon);\n        const holster = new THREE.Mesh(new THREE.BoxBufferGeometry(size, size * 4, rodSize), this.ref.materials.mat.dark);\n        const rod1 = new THREE.Mesh(new THREE.BoxBufferGeometry(size, 1, size), this.ref.materials.mat.dark);\n        const rod2 = rod1.clone();\n        mesh.position.set(x, y, 6);\n        holster.position.set(x, y + size * 2.5, 6);\n        rod1.position.set(x, y + size * 4.5 + 0.5, 6 + rodSize / 3);\n        rod2.position.set(x, y + size * 4.5 + 0.5, 6 - rodSize / 3);\n        rod1.rotation.y = Math.PI / 4;\n        rod2.rotation.y = Math.PI / 4;\n        this.ref.scene.scene.add(mesh, holster, rod1, rod2);\n      }\n\n      this.assets.ceilingLights = true;\n    }\n  }\n\n  addCollisionMap(obj) {\n    // recursively add object collision map\n    if (obj.type === 'Mesh') {\n      this.ref.scene.colliderSystem.add(obj);\n    } else if (obj.children && obj.children.length) {\n      obj.children.forEach(child => {\n        this.addCollisionMap(child);\n      });\n    }\n  }\n\n  update(delta) {\n    this.ref.materials.update(delta);\n    this.customExhibition.update(delta);\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/map.js?");

/***/ }),

/***/ "./js/modules/materials.js":
/*!*********************************!*\
  !*** ./js/modules/materials.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Material loader & manager */\nclass Materials {\n  constructor() {\n    this.path = `${APP_ROOT}/assets/`;\n    this.mat = {};\n    this.mat.default = new THREE.MeshPhysicalMaterial({\n      emissive: 0,\n      roughness: 1,\n      envMapIntensity: 0.25\n    });\n    this.mat.porcelain = new THREE.MeshPhysicalMaterial({\n      color: 0xffffff,\n      emissive: 0x888888,\n      emissiveIntensity: 0.6,\n      roughness: 0.55,\n      metalness: 0.125,\n      envMapIntensity: 0.5\n    });\n    this.mat.metal = new THREE.MeshPhysicalMaterial({\n      color: 0xa88e79,\n      emissive: 0x0,\n      roughness: 0.25,\n      metalness: 1.0,\n      envMapIntensity: 0.5\n    });\n    this.mat.neon = new THREE.MeshPhysicalMaterial({\n      emissive: 0xffffff,\n      emissiveIntensity: 1.0\n    });\n    this.mat.dark = new THREE.MeshPhysicalMaterial({\n      color: 0x0,\n      roughness: 0.5,\n      metalness: 0\n    });\n    const envMapSources = ['posx', 'negx', 'posy', 'negy', 'posz', 'negz'].map(filename => `${this.path}envmap/${filename}.jpg`);\n    this.envMap = new THREE.CubeTextureLoader().load(envMapSources);\n    this.normalMap = new THREE.TextureLoader().load(this.path + 'textures/noise.jpg');\n    this.normalMap.wrapS = this.normalMap.wrapT = THREE.RepeatWrapping;\n    this.normalMap.repeat.set(32, 32); // set envmaps\n\n    Object.keys(this.mat).forEach(key => {\n      if (this.mat[key].type && this.mat[key].type === 'MeshPhysicalMaterial') {\n        this.mat[key].envMap = this.envMap;\n      }\n    }); // custom shader uniforms\n\n    this.uniforms = {\n      time: {\n        value: 0\n      }\n    }; // reference file-loaded materials\n\n    this.loaded = {};\n  }\n\n  bind(root) {}\n\n  getTexture(path) {\n    const texture = new THREE.TextureLoader().load(this.path + path);\n    return texture;\n  }\n\n  conformGroup(obj) {\n    // recursively conform object groups\n    if (obj.type === 'Mesh') {\n      this.conformMaterial(obj.material);\n    } else if (obj.children && obj.children.length) {\n      obj.children.forEach(child => {\n        this.conformGroup(child);\n      });\n    }\n  }\n\n  conformMaterial(mat) {\n    if (!this.loaded[mat.name]) {\n      this.loaded[mat.name] = mat;\n    }\n\n    mat.envMap = this.envMap;\n    mat.envMapIntensity = 0.5; // material specific\n\n    switch (mat.name) {\n      case 'concrete':\n        mat.normalScale.x = 0.25;\n        mat.normalScale.y = 0.25;\n        break;\n\n      case 'gold':\n        break;\n\n      case 'neon':\n      case 'neon1':\n      case 'neon2':\n        mat.emissive = new THREE.Color(1, 1, 1);\n        mat.emissiveIntensity = 1.0; //mat.fog = false;\n\n        break;\n\n      case 'nu_metal':\n        mat.normalScale.x = 0.25;\n        mat.normalScale.y = 0.25;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  getCustomMaterial(matSource) {\n    const mat = matSource.clone();\n\n    mat.onBeforeCompile = shader => {\n      shader.vertexShader = `uniform float time;\\n${shader.vertexShader}`;\n      const beginVertex = `\n        vec4 mvp = modelMatrix * vec4(position, 1.0);\n        float theta = sin(time * 0.1 + mvp.x / 2.0);\n        float c = cos(theta);\n        float s = sin(theta);\n        float off = 1.0 * sin(time + position.x * 200.0);\n        mat3 roty = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n        //mat4 m = mat4(1, 0, 0, 0, 0, 1, 0, s * off * 2.0, 0, 0, 1, s * off, 0, 0, 0, 1);\n        vec3 p = position;\n        vec4 t = vec4(p.x + 0.25 * sin(time + p.y), p.y, p.z + 0.25 * cos(time + p.y), 1.0);\n        vec3 transformed = vec3(t.x, t.y, t.z);\n        vNormal = vNormal * roty;\n      `;\n      shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', beginVertex); // hook uniforms\n\n      shader.uniforms.time = this.uniforms.time;\n    }; //mat.roughness = 0.5;\n\n\n    return mat; //const index = shader.vertexShader.indexOf('#include <common>')''\n    //shader.vertexShader = shader.vertexShader.slice(0, index) + '//funcs here' + shader.vertexShader.slice(index);\n  }\n\n  update(delta) {\n    this.uniforms.time.value += delta;\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Materials);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/materials.js?");

/***/ }),

/***/ "./js/modules/player.js":
/*!******************************!*\
  !*** ./js/modules/player.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _maths_blend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maths/blend */ \"./js/maths/blend.js\");\n/* harmony import */ var _maths_min_angle_between__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maths/min_angle_between */ \"./js/maths/min_angle_between.js\");\n/** Player */\n\n\n\nclass Player {\n  constructor() {\n    this.position = new THREE.Vector3(-24, 1, 16);\n    this.rotation = new THREE.Vector2(Math.PI * 0.55, Math.PI * -0.05);\n    this.motion = new THREE.Vector3();\n    this.target = {\n      position: this.position.clone(),\n      rotation: this.rotation.clone(),\n      motion: this.motion.clone()\n    }; // physics\n\n    this.collider = new Collider.Collider(this.target.position, this.motion);\n    this.collider.setPhysics({\n      gravity: 20\n    }); // automatic motion and panning\n\n    this.automove = {\n      active: {\n        position: true,\n        rotation: true\n      },\n      speed: {\n        current: 0,\n        max: 7.5,\n        blend: 0.125\n      },\n      rotationSpeed: {\n        current: 0,\n        max: Math.PI / 2.5,\n        accum: Math.PI / 70\n      },\n      position: this.position.clone(),\n      rotation: new THREE.Vector2(Math.PI * 0.55, Math.PI * 0.03),\n      threshold: {\n        position: {\n          outer: 2,\n          inner: 0.02\n        },\n        rotation: Math.PI / 1000 // ~0.006\n\n      }\n    }; // physical attributes\n\n    this.speed = 6;\n    this.rotationSpeed = Math.PI * 0.5;\n    this.jump = 8;\n    this.jumpSpeedMultiplier = 0.25;\n    this.height = 3;\n    this.falling = false;\n    this.fallTime = 0;\n    this.fallTimeThreshold = 0.2;\n    this.noclip = false;\n    this.noclipSpeed = 36;\n\n    this.toggleNoclip = () => {\n      this.noclip = this.noclip == false;\n    };\n\n    this.minPitch = Math.PI * -0.125;\n    this.maxPitch = Math.PI * 0.125;\n    this.adjust = {\n      slow: 0.05,\n      normal: 0.1,\n      fast: 0.125,\n      maximum: 0.3\n    }; // input\n\n    this.keys = {\n      disabled: true\n    }; // add to scene\n\n    this.group = new THREE.Group();\n    this.light = new THREE.PointLight(0xffffff, 0.75, 12, 2);\n    this.light.position.y = this.height + 0.25;\n    this.group.add(this.light);\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.scene = root.modules.scene;\n    this.ref.scene.scene.add(this.group);\n  }\n\n  reset() {\n    this.position.set(-24, 1, 16);\n    this.rotation.set(Math.PI * 0.55, Math.PI * -0.05);\n    this.target.position.copy(this.position);\n    this.target.rotation.copy(this.rotation);\n    this.automove.active.position = true;\n    this.automove.active.rotation = true;\n    this.automove.position.copy(this.position);\n    this.automove.rotation.set(Math.PI * 0.55, Math.PI * 0.03);\n  }\n\n  move(delta) {\n    // key input to motion\n    if (this.keys.left || this.keys.right) {\n      if (this.automove.active.rotation) {\n        this.target.rotation.copy(this.rotation);\n        this.automove.active.rotation = false;\n      }\n\n      const d = (this.keys.left ? 1 : 0) + (this.keys.right ? -1 : 0);\n      this.target.rotation.x += d * this.rotationSpeed * delta;\n    }\n\n    if (this.keys.up || this.keys.down) {\n      if (this.automove.active.position) {\n        this.automove.active.position = false;\n        this.target.position.copy(this.position);\n      }\n\n      const speed = this.noclip ? this.noclipSpeed * (1 - Math.abs(Math.sin(this.target.rotation.y))) : this.speed;\n      const dir = (this.keys.up ? 1 : 0) + (this.keys.down ? -1 : 0);\n      this.target.motion.x = Math.sin(this.rotation.x) * speed * dir;\n      this.target.motion.z = Math.cos(this.rotation.x) * speed * dir;\n    } else {\n      this.target.motion.x = 0;\n      this.target.motion.z = 0;\n    }\n\n    if (this.keys.jump) {\n      if (this.motion.y == 0 || this.fallTime < this.fallTimeThreshold) {\n        this.motion.y = this.jump;\n        this.fallTime = this.fallTimeThreshold;\n      }\n    } // decide if falling\n\n\n    this.falling = this.motion.y != 0;\n    this.fallTime = this.falling ? this.fallTime + delta : 0; // noclip\n\n    if (this.noclip) {\n      this.falling = false;\n\n      if (this.keys.up || this.keys.down) {\n        const d = (this.keys.up ? 1 : 0) + (this.keys.down ? -1 : 0);\n        this.target.motion.y = Math.sin(this.target.rotation.y) * d * this.noclipSpeed;\n      } else {\n        this.target.motion.y = 0;\n      }\n\n      this.motion.y = this.target.motion.y;\n    } // reduce speed if falling\n\n\n    if (!this.falling) {\n      this.motion.x = this.target.motion.x;\n      this.motion.z = this.target.motion.z;\n    } else {\n      this.motion.x = Object(_maths_blend__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.motion.x, this.target.motion.x, this.jumpSpeedMultiplier);\n      this.motion.z = Object(_maths_blend__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.motion.z, this.target.motion.z, this.jumpSpeedMultiplier);\n    }\n  }\n\n  moveToArtwork(artwork) {\n    if (this.position.distanceTo(artwork.viewPosition) > this.automove.threshold.position.outer) {\n      // position\n      this.automove.position.copy(artwork.viewPosition);\n      this.automove.active.position = true; // rotation\n\n      this.automove.rotation.copy(artwork.viewRotation);\n      this.automove.active.rotation = true;\n    }\n  }\n\n  applyAutomove(delta) {\n    // position\n    if (this.automove.active.position) {\n      const p = this.automove.position.clone();\n      p.sub(this.position);\n      const mag = p.length();\n      p.normalize(); // increase speed, reduce speed, or stop\n\n      if (mag > this.automove.threshold.position.outer) {\n        this.automove.speed.current += (this.automove.speed.max - this.automove.speed.current) * this.automove.speed.blend;\n        p.multiplyScalar(this.automove.speed.current * delta);\n        this.position.add(p);\n      } else {\n        if (mag > this.automove.threshold.position.inner) {\n          const speed = this.automove.speed.max * (mag / this.automove.threshold.position.outer);\n          this.automove.speed.current += (speed - this.automove.speed.current) * this.automove.speed.blend;\n          p.multiplyScalar(this.automove.speed.current * delta);\n          this.position.add(p);\n        } else {\n          this.target.position.copy(this.automove.position);\n          this.automove.active.position = false;\n          this.keys.disabled = false;\n        }\n      }\n    } else {\n      this.automove.speed.current = 0;\n    } // rotation\n\n\n    if (this.automove.active.rotation) {\n      this.automove.rotationSpeed.current = Math.min(this.automove.rotationSpeed.current + this.automove.rotationSpeed.accum, this.automove.rotationSpeed.max);\n      const rx = Object(_maths_min_angle_between__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.rotation.x, this.automove.rotation.x);\n      const ry = Object(_maths_min_angle_between__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.rotation.y, this.automove.rotation.y);\n      const mag = Math.hypot(rx, ry);\n      this.rotation.x += rx * this.automove.rotationSpeed.current * delta;\n      this.rotation.y += ry * this.automove.rotationSpeed.current * delta;\n\n      if (mag < this.automove.threshold.rotation) {\n        this.automove.active.rotation = false;\n        this.target.rotation.copy(this.automove.rotation);\n      }\n    } else {\n      this.automove.rotationSpeed.current = 0;\n    }\n  }\n\n  setRotation(pitch, yaw) {\n    this.target.rotation.y = pitch;\n    this.target.rotation.x = yaw;\n    this.automove.active.rotation = false;\n  }\n\n  getTargetPosition() {\n    return this.target.position;\n  }\n\n  update(delta) {\n    this.applyAutomove(delta); // move, rotate\n\n    if (!this.keys.disabled && !this.automove.active.position) {\n      this.move(delta);\n\n      if (!this.noclip) {\n        this.collider.move(delta, this.ref.scene.colliderSystem);\n      } else {\n        this.target.position.x += this.motion.x * delta;\n        this.target.position.y += this.motion.y * delta;\n        this.target.position.z += this.motion.z * delta;\n      }\n\n      this.position.x = Object(_maths_blend__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.position.x, this.target.position.x, this.adjust.maximum);\n      this.position.y = Object(_maths_blend__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.position.y, this.target.position.y, this.adjust.maximum);\n      this.position.z = Object(_maths_blend__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.position.z, this.target.position.z, this.adjust.maximum);\n    }\n\n    if (!this.automove.active.rotation) {\n      this.rotation.x += Object(_maths_min_angle_between__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.rotation.x, this.target.rotation.x) * this.adjust.normal;\n      this.rotation.y = Object(_maths_blend__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.rotation.y, this.target.rotation.y, this.adjust.normal);\n    }\n\n    this.group.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n}\n\n;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/player.js?");

/***/ }),

/***/ "./js/modules/renderer.js":
/*!********************************!*\
  !*** ./js/modules/renderer.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../glsl */ \"./js/glsl/index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./js/modules/config.js\");\n/** Renderer */\n\n\n\nclass Renderer {\n  constructor() {\n    this.renderer = new THREE.WebGLRenderer({});\n    this.renderer.setClearColor(0xffdede, 1);\n    this.renderer.gammaInput = true;\n    this.renderer.gammaOutput = true;\n    this.renderer.gammaFactor = 2.25; // add to doc\n\n    document.querySelector('#canvas-target').appendChild(this.renderer.domElement);\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.scene = root.modules.scene.scene;\n    this.ref.camera = root.modules.camera.camera; // render passes\n\n    this.width = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].renderer.getWidth();\n    this.height = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].renderer.getHeight();\n    this.size = new THREE.Vector2(this.width, this.height);\n    const strength = 0.5;\n    const radius = 0.125;\n    const threshold = 0.96;\n    this.passRender = new THREE.RenderPass(this.ref.scene, this.ref.camera);\n    this.passPoster = new THREE.PosterPass(this.size);\n    this.passBloom = new THREE.UnrealBloomPass(this.size, strength, radius, threshold);\n    this.passBloom.renderToScreen = true; //this.passPoster.renderToScreen = true;\n    // composer\n\n    this.composer = new THREE.EffectComposer(this.renderer);\n    this.composer.addPass(this.passRender); //this.composer.addPass(this.passPoster);\n\n    this.composer.addPass(this.passBloom); // bind events\n\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  resize() {\n    this.width = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].renderer.getWidth();\n    this.height = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].renderer.getHeight();\n    this.size.set(this.width, this.height);\n    this.renderer.setSize(this.width, this.height);\n    this.composer.setSize(this.width, this.height);\n    this.passBloom.setSize(this.width, this.height);\n  }\n\n  render(delta) {\n    this.composer.render(delta);\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Renderer);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/renderer.js?");

/***/ }),

/***/ "./js/modules/scene.js":
/*!*****************************!*\
  !*** ./js/modules/scene.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Scene */\nclass Scene {\n  constructor() {\n    this.scene = new THREE.Scene();\n  }\n\n  bind(root) {\n    this.ref = {};\n  }\n\n  reset() {\n    this.colliderSystem = new Collider.System();\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Scene);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/scene.js?");

/***/ }),

/***/ "./js/modules/surface.js":
/*!*******************************!*\
  !*** ./js/modules/surface.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./js/modules/config.js\");\n/* harmony import */ var _ui_mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/mouse */ \"./js/ui/mouse.js\");\n/* harmony import */ var _ui_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/keyboard */ \"./js/ui/keyboard.js\");\n/* harmony import */ var _maths_clamp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../maths/clamp */ \"./js/maths/clamp.js\");\n/* harmony import */ var _utils_is_mobile_device__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/is_mobile_device */ \"./js/utils/is_mobile_device.js\");\n/** UI surface */\n\n\n\n\n\n\nclass Surface {\n  constructor() {\n    this.el = {\n      canvasTarget: document.querySelector('#canvas-target'),\n      artworkInfo: document.querySelector('#popup-artwork-info')\n    };\n    this.rotation = new THREE.Vector2();\n    this.timestamp = null;\n    const isMobile = Object(_utils_is_mobile_device__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    this.threshold = {\n      click: 225,\n      pan: 200,\n      mouseDelta: isMobile ? 0.5 : 0.25\n    };\n    this.scaleRotation = {\n      x: isMobile ? 0.75 : 1,\n      y: 1\n    }; // events\n\n    document.querySelectorAll('#gallery-controls .control').forEach(e => {\n      if (!isMobile) {\n        e.addEventListener('mousedown', evt => {\n          this.onControlDown(evt.currentTarget);\n        });\n        e.addEventListener('mouseup', evt => {\n          this.onControlUp(evt.currentTarget);\n        });\n        e.addEventListener('mouseleave', evt => {\n          this.onControlLeave(evt.currentTarget);\n        });\n      } else {\n        e.addEventListener('touchstart', evt => {\n          evt.preventDefault();\n          this.onControlDown(evt.currentTarget);\n        });\n        e.addEventListener('touchend', evt => {\n          evt.preventDefault();\n          this.onControlUp(evt.currentTarget);\n        });\n      }\n    });\n    this.controls = {\n      up: document.querySelector('#ctrl-U'),\n      down: document.querySelector('#ctrl-D'),\n      left: document.querySelector('#ctrl-L'),\n      right: document.querySelector('#ctrl-R')\n    };\n    this.keyboard = new _ui_keyboard__WEBPACK_IMPORTED_MODULE_2__[\"default\"](key => {\n      this.onKeyboard(key);\n    });\n    this.mouse = new _ui_mouse__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      domTarget: this.el.canvasTarget,\n      onMouseDown: evt => {\n        this.onMouseDown(evt);\n      },\n      onMouseMove: evt => {\n        this.onMouseMove(evt);\n      },\n      onMouseUp: evt => {\n        this.onMouseUp(evt);\n      }\n    });\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.scene = root.modules.scene;\n    this.ref.player = root.modules.player;\n    this.ref.canvas2d = root.modules.canvas2d;\n    this.ref.floorPlan = root.modules.floorPlan;\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  onMouseDown(evt) {\n    // record player rotation\n    this.rotation.y = this.ref.player.rotation.y;\n    this.rotation.x = this.ref.player.rotation.x;\n    this.timestamp = performance.now();\n  }\n\n  onMouseMove(evt) {\n    if (this.mouse.active) {\n      // update player rotation\n      if (!(this.ref.player.keys.left || this.ref.player.keys.right)) {\n        const yaw = this.rotation.x + this.mouse.delta.x / this.centre.x * this.scaleRotation.x;\n        let pitch = this.rotation.y + this.mouse.delta.y / this.centre.y * this.scaleRotation.y;\n        pitch = Object(_maths_clamp__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(pitch, this.ref.player.minPitch, this.ref.player.maxPitch); // reset pitch origin if clamped\n\n        if (pitch === this.ref.player.minPitch || pitch === this.ref.player.maxPitch) {\n          this.mouse.origin.y = evt.offsetY;\n          this.rotation.y = pitch;\n        }\n\n        this.ref.player.setRotation(pitch, yaw);\n      }\n    } else {\n      // update artwork nodes\n      this.ref.floorPlan.mouseOver(this.mouse.position.x, this.mouse.position.y);\n    }\n  }\n\n  onMouseUp(evt) {\n    const dt = performance.now() - this.timestamp;\n    const dx = Math.hypot(this.mouse.delta.x, this.mouse.delta.y);\n\n    if (dt < this.threshold.click && dx < window.innerWidth * this.threshold.mouseDelta) {\n      this.ref.floorPlan.click(this.mouse.position.x, this.mouse.position.y);\n    }\n  }\n\n  onControlUp(el) {\n    // up, down, left, right\n    this.ref.player.keys[el.dataset.dir] = false;\n    el.classList.remove('active');\n  }\n\n  onControlDown(el) {\n    // up, down, left, right\n    this.ref.player.keys[el.dataset.dir] = true;\n    el.classList.add('active');\n  }\n\n  onControlLeave(el) {\n    this.onControlUp(el);\n  }\n\n  onKeyboard(key) {\n    if (!this.el.artworkInfo.classList.contains('active')) {\n      switch (key) {\n        case 'a':\n        case 'A':\n        case 'ArrowLeft':\n          this.ref.player.keys.left = this.keyboard.keys[key];\n          this.controls.left.classList[this.ref.player.keys.left ? 'add' : 'remove']('active');\n          break;\n\n        case 'd':\n        case 'D':\n        case 'ArrowRight':\n          this.ref.player.keys.right = this.keyboard.keys[key];\n\n          if (this.ref.player.keys.right) {\n            this.controls.right.classList.add('active');\n          } else {\n            this.controls.right.classList.remove('active');\n          }\n\n          break;\n\n        case 'w':\n        case 'W':\n        case 'ArrowUp':\n          this.ref.player.keys.up = this.keyboard.keys[key];\n\n          if (this.ref.player.keys.up) {\n            this.controls.up.classList.add('active');\n          } else {\n            this.controls.up.classList.remove('active');\n          }\n\n          break;\n\n        case 's':\n        case 'S':\n        case 'ArrowDown':\n          this.ref.player.keys.down = this.keyboard.keys[key];\n\n          if (this.ref.player.keys.down) {\n            this.controls.down.classList.add('active');\n          } else {\n            this.controls.down.classList.remove('active');\n          }\n\n          break;\n\n        case ' ':\n          this.ref.player.keys.jump = this.keyboard.keys[key];\n          break;\n\n        case 'x':\n        case 'X':\n          // toggle noclip on ctrl+x\n          if (this.keyboard.keys['x'] || this.keyboard.keys['X']) {\n            if (this.keyboard.isControl()) {\n              this.ref.player.toggleNoclip();\n            }\n\n            this.keyboard.release('x');\n            this.keyboard.release('X');\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n\n  resize() {\n    this.width = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderer.getWidth();\n    this.height = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderer.getHeight();\n    this.centre = {\n      x: this.width / 2,\n      y: this.height / 2\n    };\n    this.el.canvasTarget.style.width = `${this.width}px`;\n    this.el.canvasTarget.style.height = `${this.height}px`;\n  }\n\n  update(delta) {\n    this.ref.floorPlan.update(delta);\n  }\n\n  render() {\n    this.ref.canvas2d.clear();\n    this.ref.floorPlan.draw(this.ref.canvas2d.getContext());\n    this.ref.canvas2d.promptTouchMove(this.mouse.active && Date.now() - this.timestamp > this.threshold.pan);\n\n    if (this.ref.player.noclip) {\n      this.ref.canvas2d.promptGodMode();\n      this.ref.canvas2d.drawDevOverlay();\n    } else {\n      this.ref.canvas2d.drawDevOverlay();\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Surface);\n\n//# sourceURL=webpack://COMGALLERY/./js/modules/surface.js?");

/***/ }),

/***/ "./js/ui/keyboard.js":
/*!***************************!*\
  !*** ./js/ui/keyboard.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Keyboard interface.  */\nclass Keyboard {\n  constructor(onEvent) {\n    this.keys = {};\n    this.onEvent = onEvent;\n    document.addEventListener('keydown', key => {\n      this.onKeyDown(key);\n    });\n    document.addEventListener('keyup', key => {\n      this.onKeyUp(key);\n    });\n  }\n\n  onKeyDown(key) {\n    this.keys[key.key] = true;\n    this.onEvent(key.key);\n  }\n\n  onKeyUp(key) {\n    this.keys[key.key] = false;\n    this.onEvent(key.key);\n  }\n\n  release(key) {\n    this.keys[key] = false;\n  }\n\n  isSpecial() {\n    return this.keys['Shift'] || this.keys['Control'] || this.keys['Alt'];\n  }\n\n  isControl() {\n    return this.keys['Control'];\n  }\n\n  isShift() {\n    return this.keys['Shift'];\n  }\n\n  isAlt() {\n    return this.keys['Alt'];\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Keyboard);\n\n//# sourceURL=webpack://COMGALLERY/./js/ui/keyboard.js?");

/***/ }),

/***/ "./js/ui/mouse.js":
/*!************************!*\
  !*** ./js/ui/mouse.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_is_mobile_device__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/is_mobile_device */ \"./js/utils/is_mobile_device.js\");\n/** Mouse interface */\n\n\nclass Mouse {\n  constructor(params) {\n    this.active = false;\n    this.position = {\n      x: 0,\n      y: 0\n    };\n    this.origin = {\n      x: 0,\n      y: 0\n    };\n    this.delta = {\n      x: 0,\n      y: 0\n    };\n    this.domTarget = params.domTarget;\n    this.onMouseDownCallback = params.onMouseDown || null;\n    this.onMouseUpCallback = params.onMouseUp || null;\n    this.onMouseMoveCallback = params.onMouseMove || null;\n\n    if (!Object(_utils_is_mobile_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()) {\n      this.domTarget.addEventListener('mousedown', evt => {\n        this.onMouseDown(evt);\n      });\n      this.domTarget.addEventListener('mousemove', evt => {\n        this.onMouseMove(evt);\n      });\n      this.domTarget.addEventListener('mouseup', evt => {\n        this.onMouseUp(evt);\n      });\n      this.domTarget.addEventListener('mouseleave', evt => {\n        this.onMouseUp(evt);\n      });\n    } else {\n      this.domTarget.addEventListener('touchstart', evt => {\n        this.onMouseDown(evt.touches[0]);\n      });\n      this.domTarget.addEventListener('touchmove', evt => {\n        this.onMouseMove(evt.touches[0]);\n      });\n      this.domTarget.addEventListener('touchend', evt => {\n        this.onMouseUp(evt.touches[0]);\n      });\n    }\n  }\n\n  onMouseDown(evt) {\n    this.active = true;\n    this.origin.x = evt.offsetX;\n    this.origin.y = evt.offsetY;\n    this.delta.x = 0;\n    this.delta.y = 0;\n\n    if (this.onMouseDownCallback) {\n      this.onMouseDownCallback(evt);\n    }\n\n    this.onMouseMove(evt);\n  }\n\n  onMouseMove(evt) {\n    this.position.x = evt.offsetX;\n    this.position.y = evt.offsetY;\n\n    if (this.active) {\n      this.delta.x = this.position.x - this.origin.x;\n      this.delta.y = this.position.y - this.origin.y;\n    }\n\n    if (this.onMouseMoveCallback) {\n      this.onMouseMoveCallback(evt);\n    }\n  }\n\n  onMouseUp(evt) {\n    this.active = false;\n\n    if (this.onMouseUpCallback) {\n      this.onMouseUpCallback(evt);\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Mouse);\n\n//# sourceURL=webpack://COMGALLERY/./js/ui/mouse.js?");

/***/ }),

/***/ "./js/ui/nav.js":
/*!**********************!*\
  !*** ./js/ui/nav.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_create_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/create_element */ \"./js/utils/create_element.js\");\n/* harmony import */ var _utils_is_safari_mobile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/is_safari_mobile */ \"./js/utils/is_safari_mobile.js\");\n/** Site Navigation */\n\n\n\nclass Nav {\n  constructor() {\n    this.el = {\n      openGallery: document.querySelector('#open-gallery-prompt'),\n      archiveItems: document.querySelectorAll('.section--archive'),\n      preview: document.querySelector('.section--preview'),\n      featured: document.querySelector('.section--featured'),\n      default: document.querySelector('.section--default'),\n      gallery: {\n        controls: document.querySelector('#gallery-controls'),\n        controlsPopup: document.querySelector('#popup-gallery-controls'),\n        navItems: document.querySelector('.gallery .nav__item'),\n        navItemGallery: document.querySelector('#nav-item-gallery'),\n        navItemControls: document.querySelector('#nav-item-controls'),\n        artworkInfoPopup: document.querySelector('#popup-artwork-info'),\n        artworkInfoPopupImage: document.querySelector('#popup-artwork-info .image'),\n        artworkInfoPopupTitle: document.querySelector('#popup-artwork-info .title'),\n        artworkInfoPopupSubtitle: document.querySelector('#popup-artwork-info .subtitle'),\n        artworkInfoPopupDesc: document.querySelector('#popup-artwork-info .desc'),\n        artworkInfoPopupLink: document.querySelector('#popup-artwork-info .link'),\n        artworkInfoPopupClose: document.querySelector('#popup-artwork-info-close')\n      }\n    }; // safari fix\n\n    if (Object(_utils_is_safari_mobile__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()) {\n      document.querySelectorAll('.fix-safari').forEach(el => {\n        el.classList.add('safari');\n      });\n    }\n  }\n\n  bind(root) {\n    this.ref = {};\n    this.ref.gallery = root.modules.gallery; // load initial exhibition\n\n    const exhibition = this.el.preview ? this.el.preview : this.el.featured ? this.el.featured : this.el.default;\n    const data = this.parseExhibitionDataTags(exhibition);\n    this.ref.gallery.load(data); // display default gallery (fallback)\n\n    if (!this.el.preview && !this.el.featured) {\n      this.el.default.classList.remove('hidden');\n    } // events\n\n\n    this.bindEvents(); // get page from hash\n\n    if (window.location.hash) {\n      const id = `#page-${window.location.hash.replace('#', '')}`;\n      const target = document.querySelector(`[data-target=\"${id}\"]`);\n\n      if (target) {\n        target.click();\n      }\n    } // remove loading screen\n\n\n    const loading = document.querySelector('.loading-screen');\n    loading.classList.remove('active');\n    setTimeout(() => {\n      loading.parentNode.removeChild(loading);\n    }, 500);\n  }\n\n  bindEvents() {\n    // gallery open/ close\n    this.el.openGallery.addEventListener('click', () => {\n      this.onOpenGallery();\n    });\n    document.querySelectorAll('.close-gallery').forEach(el => {\n      el.addEventListener('click', () => {\n        this.onCloseGallery();\n      });\n    }); // bind wrapper nav items\n\n    document.querySelectorAll('.wrapper .nav__item').forEach(el => {\n      el.addEventListener('click', evt => {\n        this.onWrapperNavItem(evt.target);\n      });\n    }); // bind archive\n\n    this.el.archiveItems.forEach(el => {\n      el.addEventListener('click', evt => {\n        if (evt.target.tagName !== 'A') {\n          const data = this.parseExhibitionDataTags(el);\n          this.ref.gallery.load(data);\n        }\n      });\n    }); // bind gallery nav items\n\n    this.el.gallery.navItemGallery.addEventListener('click', () => {\n      this.closeControlsPopup();\n      this.closeArtworkInfo();\n    });\n    this.el.gallery.navItemControls.addEventListener('click', evt => {\n      if (evt.target.classList.contains('active')) {\n        this.closeControlsPopup();\n      } else {\n        this.openControlsPopup();\n        this.closeArtworkInfo();\n      }\n    });\n    this.el.gallery.artworkInfoPopupClose.addEventListener('click', () => {\n      this.closeArtworkInfo();\n    }); // trigger resize after orientationchange\n\n    window.addEventListener('orientationchange', () => {\n      setTimeout(() => {\n        window.dispatchEvent(new Event('resize'));\n      }, 500);\n    });\n  }\n\n  parseExhibitionDataTags(el) {\n    const data = {};\n    data.id = el.querySelector('[data-id]').dataset.id;\n    data.title = el.querySelector('.section__title').innerHTML;\n    data.artistName = el.querySelector('.section__heading').innerHTML;\n    data.date = el.querySelector('.section__date').innerHTML;\n    data.images = [];\n    el.querySelectorAll('.section__image').forEach(img => {\n      const res = {};\n      Object.keys(img.dataset).forEach(key => {\n        res[key] = img.dataset[key];\n      });\n      res.horizontalOffset = parseFloat(res.horizontalOffset);\n      res.verticalOffset = parseFloat(res.verticalOffset);\n      res.width = parseFloat(res.width);\n      res.location = parseInt(res.location);\n      data.images.push(res);\n    });\n    data.customValue = el.querySelector('.section__custom-value').dataset.customValue;\n    return data;\n  }\n\n  onOpenGallery() {\n    if (!this.el.openGallery.classList.contains('loading')) {\n      this.el.openGallery.classList.remove('prompt-action');\n      document.querySelector('html').classList.add('freeze');\n      document.querySelector('.gallery').classList.add('active');\n      document.querySelector('.wrapper').classList.remove('active');\n      document.querySelector('.logo').classList.remove('active');\n      document.documentElement.scrollTop = 0;\n      setTimeout(() => {\n        this.ref.gallery.start();\n      }, 500);\n    }\n  }\n\n  onCloseGallery() {\n    this.ref.gallery.pause();\n    document.querySelector('html').classList.remove('freeze');\n    document.querySelector('.gallery').classList.remove('active');\n    document.querySelector('.wrapper').classList.add('active');\n    document.querySelector('.logo').classList.add('active');\n  }\n\n  openArtworkInfo(artwork) {\n    // open popup\n    if (!artwork.isArtworkMenuMine()) {\n      this.el.gallery.artworkInfoPopup.dataset.id = artwork.id;\n      this.el.gallery.artworkInfoPopupImage.innerHTML = `<img src=\"${artwork.data.url}\"/>`;\n      this.el.gallery.artworkInfoPopupTitle.innerHTML = artwork.data.title;\n      this.el.gallery.artworkInfoPopupSubtitle.innerHTML = artwork.data.subTitle;\n      this.el.gallery.artworkInfoPopupDesc.innerHTML = artwork.data.description;\n      this.el.gallery.artworkInfoPopupLink.innerHTML = artwork.data.link ? `<a href='${artwork.data.link}' target='_blank'>Link</a>` : '';\n    }\n\n    this.el.gallery.artworkInfoPopup.classList.add('active'); // rm controls & controls help, update nav\n\n    this.el.gallery.controls.classList.remove('active');\n    this.el.gallery.controlsPopup.classList.remove('active');\n    this.el.gallery.navItemControls.classList.remove('active');\n    this.el.gallery.navItemGallery.classList.add('active');\n  }\n\n  closeArtworkInfo() {\n    this.el.gallery.artworkInfoPopup.classList.remove('active');\n    this.el.gallery.controls.classList.add('active');\n  }\n\n  openControlsPopup() {\n    // open controls popup, rm controls, update nav\n    this.el.gallery.controlsPopup.classList.add('active');\n    this.el.gallery.controls.classList.remove('active');\n    this.el.gallery.navItemControls.classList.add('active');\n    this.el.gallery.navItemGallery.classList.remove('active');\n  }\n\n  closeControlsPopup() {\n    // rm controls popup, show controls, update nav\n    this.el.gallery.controlsPopup.classList.remove('active');\n    this.el.gallery.controls.classList.add('active');\n    this.el.gallery.navItemControls.classList.remove('active');\n    this.el.gallery.navItemGallery.classList.add('active');\n  }\n\n  onWrapperNavItem(el) {\n    if (el.dataset.target) {\n      const target = document.querySelector(el.dataset.target);\n\n      if (target) {\n        document.querySelectorAll('.page.active, .wrapper .nav__item.active').forEach(el => {\n          el.classList.remove('active');\n        });\n        target.classList.add('active');\n        el.classList.add('active');\n        window.location.hash = `${el.dataset.target.split('-')[1]}`;\n      }\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Nav);\n\n//# sourceURL=webpack://COMGALLERY/./js/ui/nav.js?");

/***/ }),

/***/ "./js/utils/create_element.js":
/*!************************************!*\
  !*** ./js/utils/create_element.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Create DOM Element */\nfunction CreateElement(params) {\n  const res = document.createElement(params.type || 'div');\n  Object.keys(params).forEach(key => {\n    const type = typeof params[key];\n\n    if (type === 'object') {\n      // append child nodes recursively\n      if (key === 'childNodes') {\n        params[key].forEach(child => {\n          const childNode = CreateElement(child);\n          res.appendChild(childNode);\n        });\n      } // style\n      else if (key === 'style') {\n          Object.keys(params[key]).forEach(attr => {\n            res.style[attr] = params[key][attr];\n          });\n        } // bind events\n        else if (key === 'eventListeners' || key === 'addEventListener') {\n            Object.keys(params[key]).forEach(evt => {\n              res.addEventListener(evt, params[key][evt]);\n            });\n          } // set nested values\n          else {\n              Object.keys(params[key]).forEach(subkey => {\n                res[key][subkey] = params[key][subkey];\n              });\n            }\n    } else if (type === 'number' || type === 'string') {\n      // set classes\n      if (key === 'classList') {\n        params[key].split(' ').forEach(c => {\n          res.classList.add(c);\n        });\n      } // set value\n      else {\n          res[key] = params[key];\n        }\n    }\n  });\n  return res;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CreateElement);\n\n//# sourceURL=webpack://COMGALLERY/./js/utils/create_element.js?");

/***/ }),

/***/ "./js/utils/is_mobile_device.js":
/*!**************************************!*\
  !*** ./js/utils/is_mobile_device.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Detect mobile device (smartphone/ tablet) */\nconst IsMobileDevice = () => {\n  var check = false;\n\n  (function (a) {\n    if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true;\n  })(navigator.userAgent || navigator.vendor || window.opera);\n\n  return check;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (IsMobileDevice);\n\n//# sourceURL=webpack://COMGALLERY/./js/utils/is_mobile_device.js?");

/***/ }),

/***/ "./js/utils/is_safari_mobile.js":
/*!**************************************!*\
  !*** ./js/utils/is_safari_mobile.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Detect Safari on mobile */\nconst IsSafariMobile = () => {\n  var ua = window.navigator.userAgent;\n  var iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);\n  var webkit = !!ua.match(/WebKit/i);\n  return iOS && webkit && !ua.match(/CriOS/i);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (IsSafariMobile);\n\n//# sourceURL=webpack://COMGALLERY/./js/utils/is_safari_mobile.js?");

/***/ })

/******/ });